<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-03-16 Thu 11:43 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notes Cpp</title>
<meta name="author" content="Cherno" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="icon" type="image/png" href="https://deepalgorithms.in/assets/icons/favicon.png">
<link rel="stylesheet" type="text/css" href="readtheorg-htmlize.css"/>
<link rel="stylesheet" type="text/css" href="readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Notes Cpp</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orged019c0">C++ basics without class</a>
<ul>
<li><a href="#orgc16d15f">Why C++ ?</a>
<ul>
<li><a href="#orgcbbfdb1">How C++ complier and linker works</a></li>
<li><a href="#org8a8088a">C++ Vs other prg language</a></li>
</ul>
</li>
<li><a href="#org71f0188">C complier why use cmake</a></li>
<li><a href="#org9cb25a7">Data types</a>
<ul>
<li><a href="#org8fe252c">Introduction</a></li>
<li><a href="#orgd154028">String</a></li>
<li><a href="#org776e68d">Array</a></li>
<li><a href="#org04f5eb7">Enumerator</a></li>
<li><a href="#org260fcdb">Union</a></li>
<li><a href="#orgaeea9c6">Structor</a></li>
<li><a href="#orgab97e1d">mutable : it can chanage</a></li>
</ul>
</li>
<li><a href="#org43bd6a3"><span class="todo TODO">TODO</span> Typedef</a></li>
<li><a href="#org05162d0">Operator</a>
<ul>
<li><a href="#org427789e">arithematic operator</a></li>
<li><a href="#orge88400d">relation operator</a></li>
<li><a href="#org1663653">Logical</a></li>
<li><a href="#org610a140">Conditoin Opearator (Ternary operator)</a></li>
<li><a href="#org22fefab">assignment operator</a></li>
<li><a href="#orgfe0ec72">Bitwise Opearator</a></li>
<li><a href="#org7306550">other</a></li>
</ul>
</li>
<li><a href="#orge5efcee"><span class="todo TODO">TODO</span> Escape sequence</a></li>
<li><a href="#org36bfead">Constant</a>
<ul>
<li><a href="#org4eba71e">#define</a></li>
<li><a href="#org98d5187">const:</a></li>
</ul>
</li>
<li><a href="#org52c132a">Structure</a></li>
<li><a href="#org8324da4">Pointer Vs Reference</a>
<ul>
<li><a href="#org94cedc2">Pro and Cons for Pointer and Ref</a></li>
<li><a href="#org4466fe4">Example</a></li>
</ul>
</li>
<li><a href="#org8541770">Function</a>
<ul>
<li><a href="#orgdb306bb">Syntax</a></li>
<li><a href="#org5a8d023">Declaration</a></li>
<li><a href="#orgecf6df3">Defination</a></li>
<li><a href="#orga165790">Call by value :</a></li>
<li><a href="#orgb128734">Call by ref Vs Call by pointer</a></li>
<li><a href="#org37b0c35">Function return pointer</a></li>
<li><a href="#orgdc58fdd">Inline Functions</a></li>
<li><a href="#org5701d4c">Function Overload</a></li>
<li><a href="#org5aa8b11"><span class="todo TODO">TODO</span> Recurssion</a></li>
</ul>
</li>
<li><a href="#orgf37f2a5"><span class="todo TODO">TODO</span> Static data members and static functions</a></li>
<li><a href="#org71567ee">Storage Class</a>
<ul>
<li><a href="#org5f1f2b8">Intro</a></li>
<li><a href="#org1f7fbb4">auto     :(default) stores in primary memory (RAm)</a></li>
<li><a href="#orgb1fff71">registor : register eg: counter</a></li>
<li><a href="#orge0c17c7">static   : complier will keep var existance throughout the prg(.cpp file) eg: total</a></li>
<li><a href="#org7ab51f5">external : refer to all global var visible in all prg file</a></li>
<li><a href="#orgf316882">mutable  :</a></li>
</ul>
</li>
<li><a href="#orgb464113"><span class="todo TODO">TODO</span> include and namespace</a></li>
<li><a href="#org1e2f8d0"><span class="todo TODO">TODO</span> Namespace</a></li>
</ul>
</li>
<li><a href="#org40feefe">Basic II</a>
<ul>
<li><a href="#org6e5fa0d">Vector</a></li>
<li><a href="#org971cf30">Libraries</a>
<ul>
<li><a href="#orge633143">Create own lib</a></li>
</ul>
</li>
<li><a href="#org758b491">Templet</a>
<ul>
<li><a href="#org7aacfea">Function Templet</a></li>
<li><a href="#orgcfd1bbb">Class Templet</a></li>
<li><a href="#org9746b6b"><span class="todo TODO">TODO</span> Std Temple library</a></li>
</ul>
</li>
<li><a href="#org6582be2"><span class="todo TODO">TODO</span> Preprocess</a>
<ul>
<li><a href="#org573f929">include</a></li>
<li><a href="#org18cb0b0">pragma</a></li>
<li><a href="#org8f7f142">ifndefin</a></li>
<li><a href="#org3db574d">macro</a></li>
</ul>
</li>
<li><a href="#org1f9412f"><span class="todo TODO">TODO</span> Exception Handling</a></li>
<li><a href="#org534f392"><span class="todo TODO">TODO</span> multi-threading</a>
<ul>
<li><a href="#org91ba869">Creating Threads</a></li>
<li><a href="#orga6da2f3">Terminating Threads</a></li>
<li><a href="#orgce2b5bb">Passing Arguments to Threads</a></li>
<li><a href="#org9af8a72">Joining &amp; Detaching Threads</a></li>
</ul>
</li>
<li><a href="#orge1cd0ab"><span class="todo TODO">TODO</span> Files and Streams:</a>
<ul>
<li><a href="#orge5802e0">syanatx</a></li>
<li><a href="#orgf199bae">Example</a></li>
<li><a href="#org989ca93">Closing a file</a></li>
</ul>
</li>
<li><a href="#org0c63859">Auto keyword</a></li>
<li><a href="#org0241e37">std::array</a></li>
<li><a href="#org669ca67">Dynamic memory allocation</a>
<ul>
<li><a href="#orgd046035">new and delete</a></li>
<li><a href="#org34e5f36">Example: [heap using (new but not del) or (auto delete ) heap having scope ]</a></li>
<li><a href="#org0d4d7da">Stack vs heap</a></li>
<li><a href="#orgfb2ad89">heap</a></li>
<li><a href="#org2bcf255"><span class="todo TODO">TODO</span> Smart Pointer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcf550ca">Class and objects</a>
<ul>
<li><a href="#org1728e7f">Syntax</a></li>
<li><a href="#org28142c7">Defining member function outside class by scope resolution(::)</a></li>
<li><a href="#org8a95430">this</a>
<ul>
<li><a href="#orgba40b90">Example</a></li>
</ul>
</li>
<li><a href="#org2252fbb">Constructor</a>
<ul>
<li><a href="#orgf51d2e7">Intro</a></li>
<li><a href="#org034b555">(Default,Parameter, Copy) Constructor</a></li>
<li><a href="#orgae9a4c0">Construction DEPTH</a></li>
<li><a href="#org1d02455">Initializer List</a></li>
<li><a href="#orge551c79">member initializer</a></li>
<li><a href="#org26477f1">Copying and Copy Constructor</a></li>
</ul>
</li>
<li><a href="#org156c080">Destructor</a>
<ul>
<li><a href="#org62b31cc">Syntax</a></li>
<li><a href="#org76df0ba">Exampel mem as a pointer</a></li>
</ul>
</li>
<li><a href="#org3c78401">Class as Pointer</a></li>
<li><a href="#orgd5426d8">Visibility</a></li>
<li><a href="#org2912f73"><span class="done DONE">DONE</span> Function overload</a>
<ul>
<li><a href="#org6b94e2c">Introduction</a></li>
<li><a href="#orgc9b8cc3"><span class="todo TODO">TODO</span> Example</a></li>
<li><a href="#orgfac2307">How it work</a></li>
<li><a href="#orgf3f233e">Rules where function overload doesn't work</a></li>
<li><a href="#orgb4bcadb">Function Hiding using scope</a></li>
</ul>
</li>
<li><a href="#orgb7c35fc">Operator Overloading</a>
<ul>
<li><a href="#orgd497baf">Syntax for class members</a></li>
<li><a href="#orgb5a9c39">Syntax for non-members functions</a></li>
<li><a href="#org251c0cc">Example</a></li>
<li><a href="#org75bd240">Example without operator overloading</a></li>
<li><a href="#org3cdb348">Example with operator overloading</a></li>
</ul>
</li>
<li><a href="#org2330de2">Object (Create / Instantiate Object)</a></li>
</ul>
</li>
<li><a href="#org9fea8ec">oops</a>
<ul>
<li><a href="#org1ce5b2d">Inheritance</a>
<ul>
<li><a href="#orgc21528d">Introduction</a></li>
<li><a href="#orgc3ac0b4">Syntax</a></li>
<li><a href="#org9f31419">Example</a></li>
<li><a href="#org37cc935">Types of inheritance by Acess Specifier</a></li>
<li><a href="#orgae25822">multipule Inheritance:</a></li>
</ul>
</li>
<li><a href="#org41a5c0f">Virtual and Pure Virtual Function:</a>
<ul>
<li><a href="#org4a47faf">Example</a></li>
<li><a href="#orgeabf417">Syntax</a></li>
<li><a href="#org2130914">Example for virtual function</a></li>
<li><a href="#org0dc3f6b">Pure virtual function :</a></li>
<li><a href="#org9d83dc1">Example for Pure Virtual Function</a></li>
<li><a href="#orgb8e3679">Example 2: Create fucntion which print class name</a></li>
<li><a href="#orgd4dc750">How it work</a></li>
<li><a href="#org3947fc1">Dynamic Linkage :</a></li>
</ul>
</li>
<li><a href="#orgaf85c5f">Interfaces by Abstract Class</a>
<ul>
<li><a href="#orgf7a1345">Defination</a></li>
<li><a href="#org50c23f5">Example :</a></li>
</ul>
</li>
<li><a href="#org7e43d67">Abstraction</a>
<ul>
<li><a href="#orgdf3f143">Explination</a></li>
<li><a href="#org54546fc"><span class="todo TODO">TODO</span> Data Abstracting</a></li>
<li><a href="#orgc65f243">Abstract Data Type:</a></li>
</ul>
</li>
<li><a href="#org1913ae7">Encapsulation</a></li>
<li><a href="#orgd58bbf0">Data hiding</a></li>
<li><a href="#org14d8b65">Data Hiding vs Encapsulation</a></li>
<li><a href="#orgd3df533">Polymorhism</a>
<ul>
<li><a href="#orge125f58">Introduction</a></li>
<li><a href="#org9b1c22c">Example</a></li>
<li><a href="#org84f0100">How it work</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3cc91fe">Interview Questions</a>
<ul>
<li><a href="#orgfd62209">Difference between void and void pointer:</a></li>
<li><a href="#orgb215988">Difference in Reference variable and pointer variable</a></li>
<li><a href="#org7ad2434">multiple return value</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
CppNuts : tutorial is like how to apply c++ and techincal details
<a href="https://www.youtube.com/watch?v=6Q0Cff29YwU&amp;index=36&amp;list=PLk6CEY9XxSIAQ2vE_Jb4Dbmum7UfQrXgt">https://www.youtube.com/watch?v=6Q0Cff29YwU&amp;index=36&amp;list=PLk6CEY9XxSIAQ2vE_Jb4Dbmum7UfQrXgt</a>
Cherno Project
<a href="https://www.youtube.chttps//www.quora.com/If-Linux-is-open-source-Android-is-open-source-then-why-dont-Android-apps-are-open-sourceom/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;disable_polymer=true">https://www.youtube.chttps//www.quora.com/If-Linux-is-open-source-Android-is-open-source-then-why-dont-Android-apps-are-open-sourceom/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;disable_polymer=true</a>
</p>

<div id="outline-container-orged019c0" class="outline-2">
<h2 id="orged019c0">C++ basics without class</h2>
<div class="outline-text-2" id="text-orged019c0">
</div>
<div id="outline-container-orgc16d15f" class="outline-3">
<h3 id="orgc16d15f">Why C++ ?</h3>
<div class="outline-text-3" id="text-orgc16d15f">
<p>
If we want to write fast and easy prg then c++ is the most widly used prg lang (untill go came ) 
Because it give direct control of hardware 
Widely used platform windows, mac, linux, andriod, emebeded system
</p>
</div>
<div id="outline-container-orgcbbfdb1" class="outline-4">
<h4 id="orgcbbfdb1">How C++ complier and linker works</h4>
<div class="outline-text-4" id="text-orgcbbfdb1">
<p>
when (.cpp) is compiled it will create a (.obj) 
this  obj file is assembly level instructions that
obj file are give to  linker to create a binary file or executable file.
</p>
</div>
</div>
<div id="outline-container-org8a8088a" class="outline-4">
<h4 id="org8a8088a">C++ Vs other prg language</h4>
<div class="outline-text-4" id="text-org8a8088a">
<p>
C++ is one of the oldest prg lang 80's having a large background and community (gameing, linux, open-source)
Other Prg language like c#, Jave the code is converted to intermediate language by  virtual meachine 
then a translator(basically c or c++) is used to convert intermediate lang to binary code
This make c++ faster but it does't mean code is c++ is faster if you code eis bad code
</p>
</div>

<ul class="org-ul">
<li><a id="org506d972"></a>Con's<br />
<div class="outline-text-5" id="text-org506d972">
<p>
C#, Java , Python make optimize virtual meachine which make code faster and matches with C++
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org71f0188" class="outline-3">
<h3 id="org71f0188">C complier why use cmake</h3>
</div>
<div id="outline-container-org9cb25a7" class="outline-3">
<h3 id="org9cb25a7">Data types</h3>
<div class="outline-text-3" id="text-org9cb25a7">
</div>
<div id="outline-container-org8fe252c" class="outline-4">
<h4 id="org8fe252c">Introduction</h4>
<div class="outline-text-4" id="text-org8fe252c">
<ul class="org-ul">
<li>Primative Types (Build-in Type) :
<ul class="org-ul">
<li>void</li>
<li>Integral type 
<ul class="org-ul">
<li>int</li>
<li>char</li>
</ul></li>
<li>Float type :
<ul class="org-ul">
<li>float</li>
<li>double</li>
</ul></li>
</ul></li>
<li>Derived Data Type :
<ul class="org-ul">
<li>Array</li>
<li>pointer</li>
<li>reference</li>
<li>functions</li>
</ul></li>
<li>User Defined Data Type :
<ul class="org-ul">
<li>Enumerator</li>
<li>Structure</li>
<li>Union</li>
<li>Class</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd154028" class="outline-4">
<h4 id="orgd154028">String</h4>
<div class="outline-text-4" id="text-orgd154028">
<p>
char uft-8 : 128 char
uft-16,uft-32 used for other languages 
</p>

<p>
string end with null '\0'or 0 (no. notation of ascii null)
</p>
<div class="org-src-container">
<pre class="src src-cpp">char name[6] = {'C','h','e', 'n', 'o','\0'}; // or 0 
char* name = "Cherno" 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp">void PrintString(const string&amp; str1)
{
  str1 = str1 + "h" // Error : we defined this function such a way that we should n't  manupulate the data while printing
    cout&lt;&lt; str1&lt;&lt; endl;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org776e68d" class="outline-4">
<h4 id="org776e68d">Array</h4>
<div class="outline-text-4" id="text-org776e68d">
<div class="org-src-container">
<pre class="src src-cpp">int main()
{
  int a[5];
  int* p = a;
  for (int i = 0; i&lt; 5;i++)
    example[i] =i*i;
  a[2] = 5;
  //OR WE CAN USE POINTER
  *(ptr +2)= 5;
  //OR using different data type pointer
  *(int*) ( (char*) ptr +2*(4/1) ) = 6; // ptr is char type so size is 1byte but data is 4byte so we use 2*4


}

</pre>
</div>
</div>
</div>
<div id="outline-container-org04f5eb7" class="outline-4">
<h4 id="org04f5eb7">Enumerator</h4>
<div class="outline-text-4" id="text-org04f5eb7">
<p>
Var or identifier has fixed set of o/p 
</p>
<div class="org-src-container">
<pre class="src src-cpp">  enum enumType_Name {list_of_output } var_name;
  //eg:
  enum color {red,green=6, blue, black} c;
  c = blue;

  color mycolor = red;

enum Example : uns igned char
  { A = 5, B,C}
</pre>
</div>
</div>
</div>
<div id="outline-container-org260fcdb" class="outline-4">
<h4 id="org260fcdb">Union</h4>
<div class="outline-text-4" id="text-org260fcdb">
<p>
has same memory
use for typeplanning (vector3, or, rgb   same memory but different name )
</p>
</div>
</div>

<div id="outline-container-orgaeea9c6" class="outline-4">
<h4 id="orgaeea9c6">Structor</h4>
</div>
<div id="outline-container-orgab97e1d" class="outline-4">
<h4 id="orgab97e1d">mutable : it can chanage</h4>
<div class="outline-text-4" id="text-orgab97e1d">
<ul class="org-ul">
<li>Two uses
<ul class="org-ul">
<li><p>
const in class 
</p>
<div class="org-src-container">
<pre class="src src-cpp"> class Entity
{
private:
  string m_name;
  int int_debugcount;
  mutalbe int mut_debugcount;
public:
  cosnt string&amp; Getx() const           //  this method can't modify any of class mem variables 
  {
    int_debugcount++;   //ERROR : can't change
    mut_debugcount++;    // No error : can change var in const function
    return m_x;
  }
};
</pre>
</div></li>
<li><p>
lamdas 
</p>
<div class="org-src-container">
<pre class="src src-cpp">int main(){
  int x = 8;
  auto f = [=]() mutalbe //  pass x by value 
    {
      x++;
      cout&lt;&lt; x&lt;&lt; std:: endl;
    }
  f();


  // x = 8

  // without mutable
  auto f = [=]()  
    {
      int y = x;
      y++;
      cout&lt;&lt; y&lt;&lt; std:: endl;
    }
  f();

}
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org43bd6a3" class="outline-3">
<h3 id="org43bd6a3"><span class="todo TODO">TODO</span> Typedef</h3>
<div class="outline-text-3" id="text-org43bd6a3">
<p>
User defined name for existing type is done by typedef
</p>
<div class="org-src-container">
<pre class="src src-cpp">int main(){
  typedef          short int  int16;       //  [-2^15  2^15]
  typedef unsigned short int uint16;       //  [0 2^16]

  typedef          int  int32;             //  [-2^31 2^31]
  typedef unsigned int uint32;             //  [0  2^32]

  typedef          long int  int64;        //  [-2^63 2^63]
  typedef unsigned long int uint64;        //  [ 0 2^64]

  uint16 counter1;        // unsigned short int counter1;
  int32  x1,x2,x3,x4;     // int 
  int64  x_total;         // long int

}

</pre>
</div>
</div>
</div>
<div id="outline-container-org05162d0" class="outline-3">
<h3 id="org05162d0">Operator</h3>
<div class="outline-text-3" id="text-org05162d0">
</div>
<div id="outline-container-org427789e" class="outline-4">
<h4 id="org427789e">arithematic operator</h4>
<div class="outline-text-4" id="text-org427789e">
<p>
Uniary : -, <del>, +</del>, &#x2013;
binary : +, -, *, /, %(remainder)
</p>
</div>
</div>
<div id="outline-container-orge88400d" class="outline-4">
<h4 id="orge88400d">relation operator</h4>
<div class="outline-text-4" id="text-orge88400d">
<p>
&gt;, &lt;,&lt;=,&gt;=,==,!=
</p>
</div>
</div>
<div id="outline-container-org1663653" class="outline-4">
<h4 id="org1663653">Logical</h4>
<div class="outline-text-4" id="text-org1663653">
<p>
!, &amp;&amp;, ||
</p>
<div class="org-src-container">
<pre class="src src-cpp">bool a =0; b =1;

cout&lt;&lt; !a &lt;&lt;endl;           // !a = 1; true
cout &lt;&lt; a&amp;&amp;b &lt;&lt; endl;       // a&amp;&amp;b = 0
cout &lt;&lt; a||b &lt;&lt; endl;       // a||b = 1

</pre>
</div>
</div>
</div>

<div id="outline-container-org610a140" class="outline-4">
<h4 id="org610a140">Conditoin Opearator (Ternary operator)</h4>
<div class="outline-text-4" id="text-org610a140">
<div class="org-src-container">
<pre class="src src-cpp">(x&gt;y)? x:y;


int s_Level = 1;s_Speed = 5;
s_Speed  = (s_Level&gt;5)? 10:5;

string rank = s_Level&gt; 10 ? "master" : "Begineer";

// or

if (s_Level &gt; 10)
  rank = "master";
else
  rank = "begineer";


</pre>
</div>
</div>
</div>

<div id="outline-container-org22fefab" class="outline-4">
<h4 id="org22fefab">assignment operator</h4>
<div class="outline-text-4" id="text-org22fefab">
<p>
<code>, =</code>,+=,-<code>,/</code>,%=
</p>
</div>
</div>

<div id="outline-container-orgfe0ec72" class="outline-4">
<h4 id="orgfe0ec72">Bitwise Opearator</h4>
<div class="outline-text-4" id="text-orgfe0ec72">
<p>
uniary  : ~, &lt;&lt;(left shift) , &gt;&gt; (right shift)
binary  : ~, &amp;, | , ^(xor) 
</p>
<div class="org-src-container">
<pre class="src src-cpp">A= 60;   // A= 0011 1100
B = 13;  // B = 000 1101

// A&amp;B = 0000 1101
// A|B = 0011 1101
// A^B = 0011 0001

</pre>
</div>
</div>
</div>

<div id="outline-container-org7306550" class="outline-4">
<h4 id="org7306550">other</h4>
<div class="outline-text-4" id="text-org7306550">
<p>
sizeof()
comma
.(dot)
-&gt;(arrow)
</p>
</div>
</div>
</div>
<div id="outline-container-orge5efcee" class="outline-3">
<h3 id="orge5efcee"><span class="todo TODO">TODO</span> Escape sequence</h3>
<div class="outline-text-3" id="text-orge5efcee">
<p>
\n      new line
\t      tab
\"      "
\'      ' 
\\      \      &#x2026;&#x2026;.etc
</p>
</div>
</div>

<div id="outline-container-org36bfead" class="outline-3">
<h3 id="org36bfead">Constant</h3>
<div class="outline-text-3" id="text-org36bfead">
</div>
<div id="outline-container-org4eba71e" class="outline-4">
<h4 id="org4eba71e">#define</h4>
<div class="outline-text-4" id="text-org4eba71e">
<p>
eg: 
</p>
<div class="org-src-container">
<pre class="src src-cpp"># define newline '\n'
</pre>
</div>

<p>
'#' any line starting with is called complier directive
means:
     provide direc to complier so preprocessor will can be done
</p>

<p>
'#define':
          before exe code during compilation preprocess will replace newline with '\n'
</p>
</div>
</div>

<div id="outline-container-org98d5187" class="outline-4">
<h4 id="org98d5187">const:</h4>
<div class="outline-text-4" id="text-org98d5187">
<p>
It a promise that we are n't going to change who ever you can break your promise
</p>

<p>
The reason we use const is it will help to keep code clean alot and&#x2026;.
</p>

<p>
pointer :
</p>

<p>
similar to varilabe but can't change the contant memory is allocated, used in
</p>

<p>
fake keyword 
</p>
<div class="org-src-container">
<pre class="src src-cpp">const int max_age = 55; 

</pre>
</div>
</div>

<ul class="org-ul">
<li><a id="org817040f"></a>Use of Constant and pointer<br />
<div class="outline-text-5" id="text-org817040f">
<div class="org-src-container">
<pre class="src src-cpp">int main()
{
  // Normal Const 

  const int MAX_AGE =90;
  int const MAX_AGE =90;


  // Normal Pointer pointing a cont var 

  int* a = new int;     // create a normal pointer 
  *a  = 2;              // ASSINING VALUE 
  a = (int*) &amp;MAX_AGE;  // poin A cosnt value 
  cout &lt;&lt; a&lt;&lt;endl;

  // Pointer pointing to a constant value
  const int * a  = new int;
  int const * a  = new int;      //Both give same result as const is left side of  * 
  *a =2;                        //Error we can't  modify contant(value) of pointer
  a = (int*) &amp;MAX_AGE;
  cout &lt;&lt; a&lt;&lt;endl;

  // Pointer pointing to a constant address

  int * const a = new int;
  *a = 2;
  a = (int*) &amp;MAX_AGE;   // Error : we created pointer to point constant address 
  cout &lt;&lt; a &lt;&lt; endl;


  // Pointer pointing to a constant address and constant value
  const int* const a  = new int;
  int const * const a = new int;
  *a = 2;                // Error : we created pointer pointing to value
  a = (int*) &amp;MAX_AGE;   // Error : we created pointer to point constant address 
  cout &lt;&lt; a &lt;&lt; endl;

  std::cin.get();
}
</pre>
</div>
</div>
</li>

<li><a id="org10989b3"></a>Constant  and Class<br />
<ul class="org-ul">
<li><a id="org5a0575c"></a>Creating a class method which does't change class variables<br />
<div class="outline-text-6" id="text-org5a0575c">
<div class="org-src-container">
<pre class="src src-cpp">class Entity
{
private:
  int m_x, m_y;
public:
  int Getx() const           //  this method can't modify any of class mem variables 
  {
    m_x =2; // Error : Class mem can't  be modified in this function
    return m_x;
  }
};
</pre>
</div>
</div>
</li>
<li><a id="org52c6af7"></a>Example :<br />
<div class="outline-text-6" id="text-org52c6af7">
<div class="org-src-container">
<pre class="src src-cpp">class Entity
{
private:
  int* m_x, m_y;
public:
  const int* const GetX() const       // const int*    : we return  a  int that can't be modified
				      // const GetX()  : The contant functin cant't be modified
				      // Get const     : the class mem can't  be modified
  {
    return m_x;
  }
}
</pre>
</div>
</div>
</li>
<li><a id="orgf33de81"></a>Why we  use const methods ?<br />
<div class="outline-text-6" id="text-orgf33de81">
<p>
If other programer  is extending this function we telling this can't  we used to modify the class variables
</p>

<div class="org-src-container">
<pre class="src src-cpp">class Entity
{
private:
  int m_x, m_y;
public:
  int Getx() const           //  this method can't modify any of class mem variables 
  {
    m_x =2; // Error : Class mem can't  be modified in this function
    return m_x;
  }
};

void PrintEntity(const Entity &amp;e)       // we no't want to copy  obj ('.' large pointer and we can't  modify the obj)
{
  cout&lt;&lt; e.Get()&lt;&lt; endl; // for (const Entity &amp;e) attributes for function we use only const method such as int GetX() const 
}
</pre>
</div>
</div>
</li>

<li><a id="org4fca47d"></a>Need to change class var in const function<br />
<div class="outline-text-6" id="text-org4fca47d">
<div class="org-src-container">
<pre class="src src-cpp">class Entity
{
private:
  int m_x, m_y;
  mutalbe int var;
public:
  int Getx() const           //  this method can't modify any of class mem variables 
  {

    var =2; //  We can change class var in const methods
    return m_x;
  }
};
</pre>
</div>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org52c132a" class="outline-3">
<h3 id="org52c132a">Structure</h3>
</div>
<div id="outline-container-org8324da4" class="outline-3">
<h3 id="org8324da4">Pointer Vs Reference</h3>
<div class="outline-text-3" id="text-org8324da4">
</div>
<div id="outline-container-org94cedc2" class="outline-4">
<h4 id="org94cedc2">Pro and Cons for Pointer and Ref</h4>
<div class="outline-text-4" id="text-org94cedc2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">comparision</th>
<th scope="col" class="org-left">Pointer</th>
<th scope="col" class="org-left">Referance</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Null</td>
<td class="org-left">can point to Null</td>
<td class="org-left">Can't point to Null</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Change memory address</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">inicailized after created</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
<td class="org-left">(mush inicalize when created)</td>
</tr>

<tr>
<td class="org-left">Re-assignment memory</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Ex:</td>
<td class="org-left">int i = 17;</td>
<td class="org-left">int i = 17;</td>
<td class="org-left">// i is int type</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">int *p = &amp;i;</td>
<td class="org-left">int&amp; r = i</td>
<td class="org-left">// p is pointer type and *p,r is pointer type</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">// re-assigned value *p = &#x2026;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">*p= 20; // i  =20</td>
<td class="org-left">r=20;  //i =20</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">int *p;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">// re-assigned value  r = &#x2026;.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">p = &amp;i;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">// re-assign address p = &#x2026;..</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">//Can't re-assign addresss &amp;r !=</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">int *p =0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">//point to mem = 0 or null or null pointer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">int *p =NULL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">// Point to Null</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">int *p = nullptr;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">//int in C++11</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Ex:</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">struct Book{</td>
<td class="org-left">struct Book b1;</td>
<td class="org-left">struct Book b1;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">char name[50],title[50];</td>
<td class="org-left">struct Book *p<sub>b1</sub>;</td>
<td class="org-left">struct Book&amp; r<sub>b1</sub>=b1;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">int page,id;</td>
<td class="org-left">p<sub>b1</sub> = &amp;Book1;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">}b1;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">accessing members</td>
<td class="org-left">p<sub>b1</sub>-&gt;title</td>
<td class="org-left">r<sub>b1.title</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">(*p<sub>b1</sub>).title</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">function foramal arg</td>
<td class="org-left">swap(int *x, int *y)</td>
<td class="org-left">swap(int&amp; x ,int&amp; y)</td>
<td class="org-left">in function defination formal arg we specify</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">which datatype is used to define a function</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">function actual arg</td>
<td class="org-left">swap(int&amp; a, int&amp; b)</td>
<td class="org-left">swap(int a, int b)</td>
<td class="org-left">In function call or actual arg we specify</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">which datatype is required to pass</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Both required address and in general</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">In pointer we use (&amp;) addrress to assign</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">In ref we only use (&amp;) one time to declare ref</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">later we use ref-varaiable are normal var</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">only diff is it has same address</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org4466fe4" class="outline-4">
<h4 id="org4466fe4">Example</h4>
<div class="outline-text-4" id="text-org4466fe4">
<div class="org-src-container">
<pre class="src src-cpp">int* m_x, m_y;         // m_x is a pointer , m_y is not a pointer
int* m_x, *m_y;        // m_x, m_y are pointer
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org8541770" class="outline-3">
<h3 id="org8541770">Function</h3>
<div class="outline-text-3" id="text-org8541770">
</div>
<div id="outline-container-orgdb306bb" class="outline-4">
<h4 id="orgdb306bb">Syntax</h4>
<div class="outline-text-4" id="text-orgdb306bb">
<div class="org-src-container">
<pre class="src src-cpp">void print(x,y);         // fuction declaration

int main(){
  int a = 10, b = 3;
  print(a,b);            // function call
  return 0;
}                       // a,b is actual arguments


void print(x, y)         // function defination
{cout&lt;&lt; x &lt;&lt; y ;}       // x,y is formal arguments

</pre>
</div>
</div>
</div>

<div id="outline-container-org5a8d023" class="outline-4">
<h4 id="org5a8d023">Declaration</h4>
<div class="outline-text-4" id="text-org5a8d023">
<p>
Tell complier that this  identifer(this identifier exisit ) name (function, varialbe or calss ..etc) and its this argument type and this   return type
</p>

<p>
Then compiler  search for path for  defination either in file or folder or Project
</p>

<p>
If no result is present for var then,  declaration create(instanziate) an var by  describes its type, be it a type, object, or function. 
</p>

<p>
A declaration is what the compiler needs to accept references to that identifier. 
</p>



<div class="org-src-container">
<pre class="src src-cpp">extern int bar;
extern int g(int, int);
double f(int, double); // extern can be omitted for function declarations
class foo; // no extern allowed for type declarations
</pre>
</div>
</div>
</div>
<div id="outline-container-orgecf6df3" class="outline-4">
<h4 id="orgecf6df3">Defination</h4>
<div class="outline-text-4" id="text-orgecf6df3">
<p>
A statement that tells the compiler to allocate memory for variable,function, or class and to store in memory.
</p>

<p>
A definition actually instantiates/implements this identifier. 
</p>

<p>
It's what the linker needs in order to link references to those entities.
</p>

<div class="org-src-container">
<pre class="src src-cpp">int bar;
int g(int lhs, int rhs) {return lhs*rhs;}
double f(int i, double d) {return i+d;}
class foo {};
</pre>
</div>
</div>
</div>
<div id="outline-container-orga165790" class="outline-4">
<h4 id="orga165790">Call by value :</h4>
<div class="outline-text-4" id="text-orga165790">
<div class="org-src-container">
<pre class="src src-cpp">
</pre>
</div>

<p>
when function call occure : then variable-value (actuall argument) will be used to create in another memory for formal argument
</p>
</div>
</div>

<div id="outline-container-orgb128734" class="outline-4">
<h4 id="orgb128734">Call by ref Vs Call by pointer</h4>
<div class="outline-text-4" id="text-orgb128734">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Call by referance</th>
<th scope="col" class="org-left">Call by Pointer</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">int main {</td>
<td class="org-left">int main{</td>
</tr>

<tr>
<td class="org-left">int a = 5, b =10;</td>
<td class="org-left">int a = 5, b =10</td>
</tr>

<tr>
<td class="org-left">swap(a, b)</td>
<td class="org-left">swap(&amp;a, &amp;b)</td>
</tr>

<tr>
<td class="org-left">}</td>
<td class="org-left">}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">void swap(int&amp; x, int&amp; y)</td>
<td class="org-left">void swap(int *x, int *y)</td>
</tr>

<tr>
<td class="org-left">{</td>
<td class="org-left">{</td>
</tr>

<tr>
<td class="org-left">int temp = x;</td>
<td class="org-left">int temp = *x;</td>
</tr>

<tr>
<td class="org-left">x=y;</td>
<td class="org-left">*x = *y;</td>
</tr>

<tr>
<td class="org-left">y = temp;</td>
<td class="org-left">*y = temp;</td>
</tr>

<tr>
<td class="org-left">}</td>
<td class="org-left">}</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">comparision</th>
<th scope="col" class="org-left">Call by referance</th>
<th scope="col" class="org-left">Call by pointer</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">re-assign</td>
<td class="org-left">Can't re-assign</td>
<td class="org-left">can re-assign</td>
</tr>

<tr>
<td class="org-left">assign null point</td>
<td class="org-left">Can't assign to null pointer</td>
<td class="org-left">assign to Null pointer</td>
</tr>

<tr>
<td class="org-left">access mem in (class/struct)</td>
<td class="org-left">obj.member</td>
<td class="org-left">obj -&gt; member</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">.(dot operator)</td>
<td class="org-left">(-&gt;) (arrow operator )</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org37b0c35" class="outline-4">
<h4 id="org37b0c35">Function return pointer</h4>
<div class="outline-text-4" id="text-org37b0c35">
</div>
<ul class="org-ul">
<li><a id="orgf66e0ac"></a>syntax<br />
<div class="outline-text-5" id="text-orgf66e0ac">
<div class="org-src-container">
<pre class="src src-cpp">int *function_name (agr){
  statements;
  return xxx..;
}
</pre>
</div>
</div>
</li>

<li><a id="orgcc89d95"></a>Example<br />
<div class="outline-text-5" id="text-orgcc89d95">
<div class="org-src-container">
<pre class="src src-cpp">int *getRandom();

int main (){

  int *p;
  p = getRandom();
  for (int i = 0;i&lt;10;++i){
    cout&lt;&lt; *(p+i) &lt;&lt;endl;
  }

}

int *getRandom(){
  static int r[10];

  for(i =0; i&lt;10;++i){
    r[i] = i; 
  }
  return r;       // return pointer
}
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgdc58fdd" class="outline-4">
<h4 id="orgdc58fdd">Inline Functions</h4>
<div class="outline-text-4" id="text-orgdc58fdd">
<p>
in cpp not in c
</p>
</div>
<ul class="org-ul">
<li><a id="org3775b20"></a>synatx<br />
<div class="outline-text-5" id="text-org3775b20">
<div class="org-src-container">
<pre class="src src-cpp">inline sum (int x, inty ) { return x+y;}
</pre>
</div>
</div>
</li>
<li><a id="orgd38049b"></a>Advantages<br />
<div class="outline-text-5" id="text-orgd38049b">
<p>
Function calling overhead reduced
variable push/pop on stack is reduced
retun call from a function overhead is reduced
increase locality of refrence by utilizing instruction cache.
once inline is done compiler can also apply intra-procedural optimazation if specified
</p>
</div>
</li>

<li><a id="org98c6a85"></a>Disadvantages<br />
<div class="outline-text-5" id="text-org98c6a85">
<p>
If use too many inline function (if size of inline is large) the code size increase
Compilation overhead increase if some changes code  inside function then
</p>

<p>
Some function can't be inline like recurssion, virtual function
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org5701d4c" class="outline-4">
<h4 id="org5701d4c">Function Overload</h4>
</div>
<div id="outline-container-org5aa8b11" class="outline-4">
<h4 id="org5aa8b11"><span class="todo TODO">TODO</span> Recurssion</h4>
</div>
</div>
<div id="outline-container-orgf37f2a5" class="outline-3">
<h3 id="orgf37f2a5"><span class="todo TODO">TODO</span> Static data members and static functions</h3>
<div class="outline-text-3" id="text-orgf37f2a5">
<div class="org-src-container">
<pre class="src src-cpp">
</pre>
</div>
</div>
</div>
<div id="outline-container-org71567ee" class="outline-3">
<h3 id="org71567ee">Storage Class</h3>
<div class="outline-text-3" id="text-org71567ee">
</div>
<div id="outline-container-org5f1f2b8" class="outline-4">
<h4 id="org5f1f2b8">Intro</h4>
<div class="outline-text-4" id="text-org5f1f2b8">
<p>
Every variable in C,C++ programming has two properties: type and storage class.
</p>

<p>
Type refers to the data type of a variable. And, storage class determines the scope and lifetime of a variable.
</p>

<p>
There are 4 types of storage class:
</p>

<p>
automatic:  stores in primary memory (RAm) 
external :
static   :
register : declare register variables
</p>
</div>

<ul class="org-ul">
<li><a id="orgb1c66f7"></a>Scope &amp; Lifetime<br />
<div class="outline-text-5" id="text-orgb1c66f7">
<p>
The scope of a declaration is the part of the program for which the declaration is in acessable or effective.
</p>

<p>
The lifetime of a variable or object is the time period in which the variable/object has valid memory.
Lifetime is also called "allocation method" or "storage duration."
</p>
</div>

<ul class="org-ul">
<li><a id="org2795cbc"></a>Lifetime<br />
<div class="outline-text-6" id="text-org2795cbc">
<p>
<b>Static</b>: A static variable is stored in the data segment of the "object file" of a program. Its lifetime is the entire duration of the program's execution.
<b>Automatic</b>: An automatic variable has a lifetime that begins when program execution enters the function or statement block or compound and ends when execution leaves the block. Automatic variables are stored in a "function call stack".
<b>Dynamic</b>: The lifetime of a dynamic object begins when memory is allocated for the object (e.g., by a call to malloc() or using new) and ends when memory is deallocated (e.g., by a call to free() or using delete). Dynamic objects are stored in "the heap".
</p>
</div>
</li>
<li><a id="org2856eb5"></a>Scope:<br />
<div class="outline-text-6" id="text-org2856eb5">
<p>
The scope of any variable is actually a subset of life time. A variable may be in the memory but may not be accessible though. So, the area of our program where we can actually access our entity (variable in this case) is the scope of that variable.
</p>

<p>
The scope of any variable can be broadly categorized into three categories :
</p>

<p>
Global scope : When variable is defined outside all functions. It is then available to all the functions of the program and all the blocks program contains.
</p>

<p>
<b>Local scope</b>    :  defined inside a function or block and locally accessible within the block 
<b>Function scope</b> :  formal arguments, it is said to have function scope.
<b>Class scope</b>    : "seen" by class members.
<b>Namespace scope</b>: visible within namespace block.
<b>File scope</b>     : visible within current text file.
<b>Global scope</b>   : visible everywhere unless "hidden".
</p>
</div>
</li>

<li><a id="org755850a"></a>Scope :: operator<br />
<div class="outline-text-6" id="text-org755850a">
<p>
For understand scope operator  1st we see this example 
</p>
<div class="org-src-container">
<pre class="src src-cpp">#include&lt;stdio.h&gt;
int i = 100;          // global variable declared
void main()
{
   int i = 10;         // local variable declared
   cout&lt;&lt;"Global variable : "::i&lt;&lt;endl;
   cout&lt;&lt;"Local variable  : "&lt;&lt;i&lt;&lt;endl;

}
</pre>
</div>
<p>
Here our variable named global has global scope and lifetime, hence it outlives in memory till the program execution is completed and can be accessed by any function / block locally too. But in case of our local variable, it may outlives in memory till program execution is completed but it can be accessed from only within  the function or block it is defined in.
</p>

<p>
The basic problem here can be, we can have variable with same name defined as a global as well as local variable, and hence, it would be ambiguos as to which variable we want to actually refer to. We can resolve this issue in C++ (Advancement of C language) by the use of a special operator known as <b>scope resolution operator</b>
.
</p>
</div>
</li>
</ul>
</li>


<li><a id="orgd140589"></a>Local Variable<br />
<div class="outline-text-5" id="text-orgd140589">
<p>
The variables declared inside the function are automatic or local variables.
</p>

<p>
The local variables exist only inside the function in which it is declared. When the function exits, the local variables are destroyed. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">int main() {
    int n; // n is a local variable to main() function
    ... .. ...
}

void func() {
   int n1; // n1 is local to func() function
}
</pre>
</div>
</div>
</li>

<li><a id="org9655d1c"></a>Global Variable<br />
<div class="outline-text-5" id="text-org9655d1c">
<p>
Variables that are declared outside of all functions are known as external variables. External or global variables are accessible to any function.
</p>

<div class="org-src-container">
<pre class="src src-cpp">#include &lt;stdio.h&gt;
void display();

int n = 5;  // global variable

int main()
{
    ++n;     // variable n is not declared in the main() function
    display();
    return 0;
}

void display()
{
    ++n;     // variable n is not declared in the display() function
    printf("n = %d", n);
}
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org1f7fbb4" class="outline-4">
<h4 id="org1f7fbb4">auto     :(default) stores in primary memory (RAm)</h4>
</div>
<div id="outline-container-orgb1fff71" class="outline-4">
<h4 id="orgb1fff71">registor : register eg: counter</h4>
<div class="outline-text-4" id="text-orgb1fff71">
<p>
The register keyword is used to declare register variables. Register variables were supposed to be faster than local variables.
</p>

<p>
However, modern compilers are very good at code optimization and there is a rare chance that using register variables will make your program faster. 
</p>

<p>
Unless you are working on embedded system where you know how to optimize code for the given application, there is no use of register variables.
</p>
</div>
</div>
<div id="outline-container-orge0c17c7" class="outline-4">
<h4 id="orge0c17c7">static   : complier will keep var existance throughout the prg(.cpp file) eg: total</h4>
<div class="outline-text-4" id="text-orge0c17c7">
</div>
<ul class="org-ul">
<li><a id="org33f77ec"></a>static inside file<br />
<div class="outline-text-5" id="text-org33f77ec">
<ol class="org-ol">
<li>If you define a var in static it can only be access only in that .cpp file and can't access outside .cpp file
means the variable can private in file can't  access in other file 
inicialize(instanciated) once even if you iniciallize twice complier will ignore the statement because already iniciallized</li>
</ol>
<div class="org-src-container">
<pre class="src src-cpp">static int i =10;
int main()
{
  static int i = 0; //static var are n't inciallize twice this stat is n't ece
  for (j=0;j&lt;5;j++)
    {
      cout&lt;&lt; i++&lt;&lt;endl;
    }
}
</pre>
</div>
<ol class="org-ol">
<li>All functions in file can acess static varialbe</li>
</ol>
</div>
</li>
<li><a id="org562ad45"></a>Static inside class<br />
<div class="outline-text-5" id="text-org562ad45">
<ol class="org-ol">
<li>All obj has (shared memory) for (static var or functions)</li>
<li>Can't access outside the class</li>
<li>Inicialized one</li>
</ol>
<div class="org-src-container">
<pre class="src src-cpp">struct Entity
{
  static int x,y;                          // static variable in str\class
  void Print(){ cout &lt;&lt;x&lt;&lt;y&lt;&lt;endl;}
  static void Sprint(){ count&lt;&lt;x&lt;&lt;y&lt;&lt;endl;} // static fun inside struct\class
};

int Entity::x;  //define static variable
int Entity::y;

int main()
{
  Entity e;
  e.x = 2;
  e.y = 3;

  Entity e1;
  e1.x = 5;
  e1.y = 8;

  e.Print();
  e1.Print();

  Entity::x = 10;
  Entity::y = 15;
  Entity::Sprint();
  e.print();
  e1.print();
}
</pre>
</div>
</div>
</li>

<li><a id="org4ae9168"></a>Static inside function:<br />
<div class="outline-text-5" id="text-org4ae9168">
<p>
Static inside function means the var/obj has entire  the function 
</p>
<div class="org-src-container">
<pre class="src src-cpp">extern j = 0;
void fun()
{
  static int i = 0;
  int k = 0;
  cout&lt;&lt;"extern j++ :"&lt;&lt; j++&lt;&lt;"Static i++ :"&lt;&lt; i++&lt;&lt;"local k++:"&lt;&lt;k++&lt;&lt;endl;
}

int main()
{
  fun();          // extern j++ : 0   Static i++ : 0   Local k++ : 0
  fun();          // extern j++ : 1   Static i++ : 1   Local k++ : 1
  j = 10;
  fun();          // extern j++ : 10  Static i++ : 2   Local k++ : 2
  fun();          // extern j++ : 11  Static i++ : 3   Local k++ : 3
  fun();          // extern j++ : 12  Static i++ : 4   Local k++ : 4
} 
</pre>
</div>
</div>
</li>
<li><a id="org9549428"></a>Advantages<br />
<div class="outline-text-5" id="text-org9549428">
<ol class="org-ol">
<li>In creating a prj with mulipile files then it is best to use static variable or else it will make var global and mess entire whole prj
In general compiling prj static var make linker n't to look outside the scope of file</li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org7ab51f5" class="outline-4">
<h4 id="org7ab51f5">external : refer to all global var visible in all prg file</h4>
</div>
<div id="outline-container-orgf316882" class="outline-4">
<h4 id="orgf316882">mutable  :</h4>
</div>
</div>
<div id="outline-container-orgb464113" class="outline-3">
<h3 id="orgb464113"><span class="todo TODO">TODO</span> include and namespace</h3>
<div class="outline-text-3" id="text-orgb464113">
<p>
cout is definded in std
cout is declared in iostream or ostream
</p>
</div>
</div>

<div id="outline-container-org1e2f8d0" class="outline-3">
<h3 id="org1e2f8d0"><span class="todo TODO">TODO</span> Namespace</h3>
</div>
</div>

<div id="outline-container-org40feefe" class="outline-2">
<h2 id="org40feefe">Basic II</h2>
<div class="outline-text-2" id="text-org40feefe">
</div>
<div id="outline-container-org6e5fa0d" class="outline-3">
<h3 id="org6e5fa0d">Vector</h3>
<div class="outline-text-3" id="text-org6e5fa0d">
<p>
dynamic array or size of the array is dynamic (resize)
</p>

<p>
generally dynamic array of std lib is not optimal so cooperating compay will have there own std lib 
</p>



<div class="org-src-container">
<pre class="src src-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;

struct Ver3
{
  float x,y,z;
};

ostream&amp; operator&lt;&lt; (ostream&amp; stm1, const ver3&amp; v3)
{
  stream&lt;&lt; v3.x&lt;&lt; ", "&lt;&lt; v3.y&lt;&lt;", "&lt;&lt;v3.z;
  return steam;
}
int main()
{
  vector&lt;Ver3&gt; vertices;
  vertices.push_back({1, 2, 3});
  vertices.push_back({4, 5, 6});

  for (int i = 0; i&lt; vertices.size(); i++)
    cout&lt;&lt; vertices[i]&lt;&lt;endl;

  for (Ver3&amp; v : vertices)
    cout&lt;&lt; v&lt;&lt; endl;
  vertices.clear();
}

</pre>
</div>
</div>
</div>
<div id="outline-container-org971cf30" class="outline-3">
<h3 id="org971cf30">Libraries</h3>
<div class="outline-text-3" id="text-org971cf30">
<p>
there are two part as
</p>
<ul class="org-ul">
<li>file consist of includes (consist of headear flies)</li>
<li>binary (lib dir has binary(.dll or .lib) )</li>
</ul>

<p>
there are two libeary 
</p>
<ul class="org-ul">
<li>static ( inside exe)</li>
<li>dynamic (linked run-time) //</li>
</ul>

<p>
add libraries
</p>

<p>
linking binarys
</p>
</div>
<div id="outline-container-orge633143" class="outline-4">
<h4 id="orge633143">Create own lib</h4>
<div class="outline-text-4" id="text-orge633143">
<div class="org-src-container">
<pre class="src src-sh">## Create a Project

# game            consist of Application(.exe,.o)
# Engine          consist of libraries (Dynamic Library(.dll), Static library (.lib)) for all configuration and platform(32bit,64bit)

mkdir gameProjectName Engine

cd gameProjectName
mkdir scr &amp;&amp; cd scr
touch Application.cpp

cd ../Engine
mkdir scr &amp;&amp; cd scr
touch Engine.cpp Engine.h
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp">// file name : Engine.h

#pragma once
namespace engine
{ void PrintMessage();}


// file name : Engine.cpp

#include "Engine.h"
#include &lt;iostream&gt;

namespace engine{
  void PrintMessage()
  {
    std::out&lt;&lt;"Hello World"&lt;&lt; std::endl;
  }
}


// application.cpp

// Below used a relavtive path
// cons : if different prj is using same lib then relative path is messing
#include "../Engine/src/Engine.h"

// // below we  complier path then
// #include "Engine.h"

#include&lt;iostream&gt;
int main()
{
  engine::PrintMessage();
}

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org758b491" class="outline-3">
<h3 id="org758b491">Templet</h3>
<div class="outline-text-3" id="text-org758b491">
</div>
<div id="outline-container-org7aacfea" class="outline-4">
<h4 id="org7aacfea">Function Templet</h4>
<div class="outline-text-4" id="text-org7aacfea">
<div class="org-src-container">
<pre class="src src-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;

template&lt;typename T&gt;
void Print(T value)
  {cout&lt;&lt; value&lt;&lt; endl;}

int main()
{
  Print(5);
  Print("Cherno");
  Print(5.0f);

  std::cin.get();
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcfd1bbb" class="outline-4">
<h4 id="orgcfd1bbb">Class Templet</h4>
<div class="outline-text-4" id="text-orgcfd1bbb">
<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include&lt;strings&gt;

template&lt;typename T, int N&gt;
class Array
{
private:
  T m_Arrany[N];
public:
  int GetSize() const { return N}
};

int main()
{
  Array&lt;int, 5&gt; array;
  cout&lt;&lt; array.Getsize()&lt;&lt; std::endl;
  cin.get();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9746b6b" class="outline-4">
<h4 id="org9746b6b"><span class="todo TODO">TODO</span> Std Temple library</h4>
</div>
</div>
<div id="outline-container-org6582be2" class="outline-3">
<h3 id="org6582be2"><span class="todo TODO">TODO</span> Preprocess</h3>
<div class="outline-text-3" id="text-org6582be2">
<p>
Function like macros
condition Compilation
'#' and ## operator
predefine macro
</p>
</div>
<div id="outline-container-org573f929" class="outline-4">
<h4 id="org573f929">include</h4>
</div>
<div id="outline-container-org18cb0b0" class="outline-4">
<h4 id="org18cb0b0">pragma</h4>
</div>
<div id="outline-container-org8f7f142" class="outline-4">
<h4 id="org8f7f142">ifndefin</h4>
</div>
<div id="outline-container-org3db574d" class="outline-4">
<h4 id="org3db574d">macro</h4>
<div class="outline-text-4" id="text-org3db574d">
<div class="org-src-container">
<pre class="src src-cpp">#include &lt; iostream&gt;

#define WAIT std::cin.get()    // macro

// Note : some time we need to see the output during debugging the code but should be removed when release the we use below version 

#if PR_DEBUG == 1                      
#define LOG(x) std::cout&lt;&lt; x&lt;&lt; endl
#elif define(PR_RELEASE)
#define LOG(x)
#endif

int main()
{
  LOG("Hello");
  WAIT;  // THIS IS Wrong way because if 
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1f9412f" class="outline-3">
<h3 id="org1f9412f"><span class="todo TODO">TODO</span> Exception Handling</h3>
</div>
<div id="outline-container-org534f392" class="outline-3">
<h3 id="org534f392"><span class="todo TODO">TODO</span> multi-threading</h3>
<div class="outline-text-3" id="text-org534f392">
</div>
<div id="outline-container-org91ba869" class="outline-4">
<h4 id="org91ba869">Creating Threads</h4>
</div>
<div id="outline-container-orga6da2f3" class="outline-4">
<h4 id="orga6da2f3">Terminating Threads</h4>
</div>
<div id="outline-container-orgce2b5bb" class="outline-4">
<h4 id="orgce2b5bb">Passing Arguments to Threads</h4>
</div>
<div id="outline-container-org9af8a72" class="outline-4">
<h4 id="org9af8a72">Joining &amp; Detaching Threads</h4>
</div>
</div>
<div id="outline-container-orge1cd0ab" class="outline-3">
<h3 id="orge1cd0ab"><span class="todo TODO">TODO</span> Files and Streams:</h3>
<div class="outline-text-3" id="text-orge1cd0ab">
<p>
To read and write a file C++ provides lib in standard C++ library called fstream, which provides 3 new data types.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Data type</td>
<td class="org-left">Description</td>
</tr>

<tr>
<td class="org-left">ofstream</td>
<td class="org-left">data type : output file stream (create file or write info )</td>
</tr>

<tr>
<td class="org-left">ifstream</td>
<td class="org-left">data type : input file stream (read info from files )</td>
</tr>

<tr>
<td class="org-left">ifsteam</td>
<td class="org-left">data type :  both input and output file stream</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orge5802e0" class="outline-4">
<h4 id="orge5802e0">syanatx</h4>
<div class="outline-text-4" id="text-orge5802e0">
<div class="org-src-container">
<pre class="src src-cpp">void open(const char "filename", ios::openmode mode);
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">mode flag</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">ios::app</td>
<td class="org-left">append mode. All output of file to be appended in end</td>
</tr>

<tr>
<td class="org-left">ios::ate</td>
<td class="org-left">open file for output and move read/write control to end of file</td>
</tr>

<tr>
<td class="org-left">ios::in</td>
<td class="org-left">open a file for reading</td>
</tr>

<tr>
<td class="org-left">ios::out</td>
<td class="org-left">file for writing</td>
</tr>

<tr>
<td class="org-left">ios::trunc</td>
<td class="org-left">if file already existed, it contents will be truncated before opening file</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgf199bae" class="outline-4">
<h4 id="orgf199bae">Example</h4>
<div class="outline-text-4" id="text-orgf199bae">
<div class="org-src-container">
<pre class="src src-cpp">//write and truncate 
ofstream outfile;
outfile.open("file.dat", ios::out | ios::trunc);

// read and write
fstream afile;
afile.open("file.dat", ios::out | ios::in);
</pre>
</div>
</div>
</div>

<div id="outline-container-org989ca93" class="outline-4">
<h4 id="org989ca93">Closing a file</h4>
<div class="outline-text-4" id="text-org989ca93">
<p>
In c++ when prg is terminates it automatically closes flushes all streams. But it is always good practice that a programmer should close all the opended files before programm termination
</p>

<div class="org-src-container">
<pre class="src src-cpp">void close();
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0c63859" class="outline-3">
<h3 id="org0c63859">Auto keyword</h3>
<div class="outline-text-3" id="text-org0c63859">
<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
char* GetName()
{
  return "Cherno";
}
class Device{};


class DeviceManager
{
private:
  unordered_map&lt;string, vector&lt;Device*&gt; &gt; m_Devices;
public:
  const unorderd_map&lt;string, vector&lt;Device*&gt; &gt;&amp; GetDevices() const;
  { return m_Devices}
}
int main()
{
  std:: vector &lt;std::string&gt; str
  str.push_back("Apple");
  str.push_back("Orange");

  for (auto it = str.begin();it != str.end();it++)
    {
     cout&lt;&lt; *it &lt;&lt; endl;
    }

  DeviceManager dm;
  const std::unorderd_map&lt; std::string, std::vector&lt;Device*&gt; &gt; device = dm.GetDevices()
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0241e37" class="outline-3">
<h3 id="org0241e37">std::array</h3>
<div class="outline-text-3" id="text-org0241e37">
<p>
simillar to secodory array but has advangaes
debug setting for auto size set, bounce checks, sort,&#x2026;etc
</p>
<div class="org-src-container">
<pre class="src src-cpp">#include &lt;iostream&gt;
#include &lt;array&gt;

void PrintArray(int* array)
int main()
{
  array&lt;int,5&gt; data;
  data[0]=2;
  data[4]=1;
  data[5]=2;    // bounce checks

  int data[5];
  data[0]= 0;
  data[5]= 0;

  std::cin.get();

}
</pre>
</div>
</div>
</div>

<div id="outline-container-org669ca67" class="outline-3">
<h3 id="org669ca67">Dynamic memory allocation</h3>
<div class="outline-text-3" id="text-org669ca67">
</div>
<div id="outline-container-orgd046035" class="outline-4">
<h4 id="orgd046035">new and delete</h4>
<div class="outline-text-4" id="text-orgd046035">
<p>
new will call malloc and  stores  size , 
</p>
<div class="org-src-container">
<pre class="src src-cpp">class Entity
{
private:
  string s1;
};

int main()
{
  int a =2;
  int *b = new int[50];
  Entity *e = new Entity;


  delete e;
  delete [] b;
  cin.get();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org34e5f36" class="outline-4">
<h4 id="org34e5f36">Example: [heap using (new but not del) or (auto delete ) heap having scope ]</h4>
<div class="outline-text-4" id="text-org34e5f36">
<div class="org-src-container">
<pre class="src src-cpp">class Entilty
{

};

class ScopedPtr
{
private:
  Entity* m_Ptr;
public:
  ScopedPrt(Entity* ptr)
    :m_Ptr(ptr){}
  ~ScopedPrt()
  { delete m_Ptr; }
};

int main ()
{
  {
    ScopePtr e = new Entity();
  }

}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0d4d7da" class="outline-4">
<h4 id="org0d4d7da">Stack vs heap</h4>
<div class="outline-text-4" id="text-org0d4d7da">
<p>
stack is 2 megabite
heap is large 
both stack and heap are stored in ram
</p>
</div>
<ul class="org-ul">
<li><a id="org5cbe513"></a>How it allocate memory in stack vs heap ?<br />
<div class="outline-text-5" id="text-org5cbe513">
<div class="org-src-container">
<pre class="src src-cpp">int main()
{
  int value = 5;
  int array[5];
  for (int i=0 ; i&lt;5;i++)
    {array[i] = i;}

  Vector3 vector;

  int* hvalue = new int;
  *hvalue= 5;

  int* harray = newint[5];
  for (int i=0 ; i&lt;5;i++)
    {harray[i] = i;}

  Vector3* hvector = new Vector3();

  delete hvalue;
  delete[] harray;
  delete hvector;
  cin.get();

}
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgfb2ad89" class="outline-4">
<h4 id="orgfb2ad89">heap</h4>
</div>
<div id="outline-container-org2bcf255" class="outline-4">
<h4 id="org2bcf255"><span class="todo TODO">TODO</span> Smart Pointer</h4>
<div class="outline-text-4" id="text-org2bcf255">
<div class="org-src-container">
<pre class="src src-cpp">#include &lt;memory&gt;

class Entity
{

};

int main()
{
  shared_ptr&lt;Entity&gt; sh_Enty = make_shared&lt;Entity&gt;();
  shared_ptr&lt;Entity&gt; sh_Enty1 = make_shared&lt;Entity&gt;();

  unique_ptr&lt;Entity&gt; sh_Enty = make_shared&lt;Entity&gt;();
  weak_ptr&lt;Entity&gt; sh_Enty = make_shared&lt;Entity&gt;();
  }
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcf550ca" class="outline-2">
<h2 id="orgcf550ca">Class and objects</h2>
<div class="outline-text-2" id="text-orgcf550ca">
</div>
<div id="outline-container-org1728e7f" class="outline-3">
<h3 id="org1728e7f">Syntax</h3>
<div class="outline-text-3" id="text-org1728e7f">
<p>
calss is blueprint of a obj,  has some properties(attributes) and behavior(functions) 
</p>
<div class="org-src-container">
<pre class="src src-cpp">class ClassName {
private:                  // by default 
  int x,y;
protected:
  char name;
public:
  void getX(int a){x = a;}
  void getY(int b){y =b;}
};

int main(){
  ClassName ObjectName ;
  ObjectName.getX(10); 
}
</pre>
</div>

<p>
default acess specifier : private 
private is used for store attribues or variables
</p>
</div>
</div>
<div id="outline-container-org28142c7" class="outline-3">
<h3 id="org28142c7">Defining member function outside class by scope resolution(::)</h3>
<div class="outline-text-3" id="text-org28142c7">
<div class="org-src-container">
<pre class="src src-cpp">class ClassName {
private:                  // by default 
  int x,y;
protected:
  char name;
};
void ClassName::getX(int a) {x = a;}
void ClassName::getY(int b) {y =b;}

int main(){
  ClassName ObjectName ;
  ObjectName.getX(10); 
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org8a95430" class="outline-3">
<h3 id="org8a95430">this</h3>
<div class="outline-text-3" id="text-org8a95430">
<p>
only in member function
</p>
</div>
<div id="outline-container-orgba40b90" class="outline-4">
<h4 id="orgba40b90">Example</h4>
<div class="outline-text-4" id="text-orgba40b90">
<div class="org-src-container">
<pre class="src src-cpp">void PrintEntity( const Entity&amp; e);
class Entity
{
public:
  int x,y;
  Entity(int x, int y)
  {
    Entity*  e = this;    // 
    this-&gt;x= x;
    this-&gt;y = y;
    PrintEntity(this);
  }

  int GetX() const
  {
    const Entity&amp; e = *this;
  }

};

void PrintEntity( const Entity&amp; e)
{
  const Entity&amp; e = *this;
}


</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2252fbb" class="outline-3">
<h3 id="org2252fbb">Constructor</h3>
<div class="outline-text-3" id="text-org2252fbb">
<p>
To iniciallize the when obj is created
</p>

<p>
Three type of Constructor
</p>
<ol class="org-ol">
<li>Default</li>
<li>Patameterize</li>
<li>Copy Constructor</li>
<li>Dynamic by using heap</li>
</ol>
</div>

<div id="outline-container-orgf51d2e7" class="outline-4">
<h4 id="orgf51d2e7">Intro</h4>
<div class="outline-text-4" id="text-orgf51d2e7">
<div class="org-src-container">
<pre class="src src-cpp">class ClassName {
  int a;
public:
  ClassName(){a = 0}                               // Constructor name is Class Name
						   // Auto matically call when we create a obj of class
						   // No return type
						   // if Not defined compiler will create it self
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org034b555" class="outline-4">
<h4 id="org034b555">(Default,Parameter, Copy) Constructor</h4>
<div class="outline-text-4" id="text-org034b555">
<div class="org-src-container">
<pre class="src src-cpp">class Point {
  double x, y ;
public:
  Point () { x= 0, y = 0;}                     // default constructors
  Point (double X, double Y) {x= X; y = Y;}    // parameter constructor  
  Point (const Point&amp; rhs) {x = rhs.x; y = rhs.y;}  // copy constructor
  // we are using constant so that we should n't accidenly change what we have to copy
  // we are copy one poperty to another property,
  // when you create a obj and want to assing it property

  double getx(X) {return x;}
  double gety(Y) {return y;}
};

int main() {
   // when obj created then constructor is called
  Point p1;             // default cons is call
  Point p2(1.2, 3.4);   // para cons
  Point p3= p1;         // copy one obj to other type


}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgae9a4c0" class="outline-4">
<h4 id="orgae9a4c0">Construction DEPTH</h4>
<div class="outline-text-4" id="text-orgae9a4c0">
<p>
Construction doesn't run if don't create a obj 
eg : static method
</p>
</div>
<ul class="org-ul">
<li><a id="orgea62357"></a>Class which doesn't allow creating obj<br />
<div class="outline-text-5" id="text-orgea62357">
<div class="org-src-container">
<pre class="src src-cpp">class Log
{
private :
  Log(){}; // hidding constructor to stop creating obj
public:
  // OR insted of making cons private we can delete
  Log()= delete;
  static void Write()
  {
    //sfadffa
  }
};

int main()
{
  Log::Write();
  Log wr ;//ERROR
}
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org1d02455" class="outline-4">
<h4 id="org1d02455">Initializer List</h4>
<div class="outline-text-4" id="text-org1d02455">
<div class="org-src-container">
<pre class="src src-cpp">class Base {
  int  x;
  int  y;
public:

   //NOTE : this is not iniciallizeing but assignment
  Base (int a, int b) {x = a; y=b; }

  Base (int a, int b):x{a},y{b}               // This is inicallization
  Base( int a, int b)
    :x{a},y{b}                              // Different formate                        

}
</pre>
</div>

<p>
There are two ways to do 
Using {} : uniform initialization and should be prefered 
Using () : round of it convert formal argument data type to data type of actual argument and then assing
</p>

<div class="org-src-container">
<pre class="src src-cpp">class Base{
  char x;
public :
  Base(int a):x(a) {}
  void print() { cout &lt;&lt; (int)x &lt;&lt; endl;}
};

int main(){
  Base b(300);
  b.print();            // prints: 44
}

</pre>
</div>
</div>
</div>

<div id="outline-container-orge551c79" class="outline-4">
<h4 id="orge551c79">member initializer</h4>
<div class="outline-text-4" id="text-orge551c79">
<p>
Should be in order :
      the members should be inicialized in order it are defined in classe or some complier give error
</p>
<div class="org-src-container">
<pre class="src src-cpp">class Entity
{
private:
  string m_Name;
  int score;
public:
  Entity() :m_Name("Unknown"),score(0)            // member inicializer
  {    
  }
  Entity(const stirng&amp; name)
    :m_Name(name)
  {}
  const string&amp; GetName() const {return m_Name;}
};
int main()
{
  Enity e0;
  cout&lt;&lt;e0.GetName()&lt;&lt;endl;

  Entity e1("Cherno");
  cout&lt;&lt;e0.GetName()&lt;&lt;endl;
  cin.get();
}
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="orgef6d99c"></a>Why?<br />
<div class="outline-text-5" id="text-orgef6d99c">
<ul class="org-ul">
<li>code style is easy to write and read</li>
<li>Function Defernece</li>
</ul>

<p>
Without using member inicializer 
</p>
<div class="org-src-container">
<pre class="src src-cpp">   class Example
   {
   public:
     Example()
     { cout&lt;&lt; "Create Entity! "&lt;&lt; endl;}
     Example(int x)
     {cout&lt;&lt; "Create Entity  with "&lt;&lt;x&lt;&lt;"!"&lt;&lt;endl;}
   }
   class Entity
   {
   private:
     string m_Name;
     Example m_Example;     // it create a object
   public:
     Entity()          // NO-member inicializer
     {
       m_Name =  string("Unknow");
       m_Example = Example(8); // over writen the 
     }
     Entity(const stirng&amp; name)
       :m_Name(name)
     {}

   };
   int main()
   {
     Enity e0;
     cin.get();
   }

// // Result is 
// Create Entity !
// Create Entitywith 8 !
</pre>
</div>
<p>
We can see if there is no member inicilizer the we are createing two object of enitiy
</p>

<p>
By using member iniclizer 
</p>
<div class="org-src-container">
<pre class="src src-cpp">   class Example
   {
   public:
     Example()
     { cout&lt;&lt; "Create Entity! "&lt;&lt; endl;}
     Example(int x)
     {cout&lt;&lt; "Create Entity  with "&lt;&lt;x&lt;&lt;"!"&lt;&lt;endl;}
   }
   class Entity
   {
   private:
     string m_Name;
     Example m_Example;     // it create a object c++ will not do it for primitive data types
   public:
     Entity()          // NO-member inicializer
       : m_Example(8)
     {
       m_Name =  string("Unknow");

     }
     Entity(const stirng&amp; name)
       :m_Name(name)
     {}

   };
   int main()
   {
     Enity e0;
     cin.get();
   }

// // Result is 
// Create Entity !

</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-org26477f1" class="outline-4">
<h4 id="org26477f1">Copying and Copy Constructor</h4>
</div>
</div>
<div id="outline-container-org156c080" class="outline-3">
<h3 id="org156c080">Destructor</h3>
<div class="outline-text-3" id="text-org156c080">
</div>
<div id="outline-container-org62b31cc" class="outline-4">
<h4 id="org62b31cc">Syntax</h4>
<div class="outline-text-4" id="text-org62b31cc">
<div class="org-src-container">
<pre class="src src-cpp">class Base{
  int x;
  Base () {cout &lt;&lt; "Default constructor " &lt;&lt; endl;}
  Base(int a):x{a}{cout &lt;&lt; "Parameter Construtor "&lt;&lt; endl;}
  ~Base(){ cout &lt;&lt; "Destructor"&lt;&lt; endl;}                         // start with ~
								 // used to destroy memory of obj 
								  // get call automatically by complier simillar to constructor
								 // we use manually or explicity for dyanmic memory allocation(new, pointer)
};

int main(){
  Base b (19);
  b.~Base();

  return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org76df0ba" class="outline-4">
<h4 id="org76df0ba">Exampel mem as a pointer</h4>
<div class="outline-text-4" id="text-org76df0ba">
<div class="org-src-container">
<pre class="src src-cpp">class Base{
  int *x;
  int *y;
  Base ():x{nullptr} {cout &lt;&lt; "Default constructor " &lt;&lt; endl;}
  Base(int a):x{a}{cout &lt;&lt; "Parameter Construtor "&lt;&lt; endl;}
  ~Base(){   // generally used to dele dynamic memory otherwise complier will delete it
    delete x;
    delete y;
    cout &lt;&lt; "Destructor"&lt;&lt; endl;}
};

int main(){
  Base b(new int(10));    // new is used for allocating dynamic memory

  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org3c78401" class="outline-3">
<h3 id="org3c78401">Class as Pointer</h3>
<div class="outline-text-3" id="text-org3c78401">
<div class="org-src-container">
<pre class="src src-cpp">class Base{
  char x;
public :
  int y;
  Base(char a):x{a}{}
  void print(){cout &lt;&lt; x &lt;&lt; endl;}
};

int main(){
  Base b1("A");
  b1.y = 100;
  b1.print();
  cout&lt;&lt;b.y&lt;&lt;endl;
  Base* e = &amp;b1;
  e -&gt;print();
  cout&lt;&lt;e-&gt;y&lt;&lt;endl;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd5426d8" class="outline-3">
<h3 id="orgd5426d8">Visibility</h3>
<div class="outline-text-3" id="text-orgd5426d8">
<p>
In c++ has visibility of class are of three types: private, protected, public, friend (function and class)
</p>

<p>
C++ restricts acess of class mem (var and funct) based on acess sepecifer
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">acess\Class</th>
<th scope="col" class="org-left">base Class Public</th>
<th scope="col" class="org-left">base Class Protected</th>
<th scope="col" class="org-left">base Class Private</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">ouside side</td>
<td class="org-left">can acess public mem</td>
<td class="org-left">can't acess procted mem</td>
<td class="org-left">can't  acess privat mem</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">baseclass pubic function</td>
<td class="org-left">can acess public mem</td>
<td class="org-left">can acess proteced mem</td>
<td class="org-left">can acess private mem</td>
</tr>

<tr>
<td class="org-left">baseclass procted function</td>
<td class="org-left">can acess public mem</td>
<td class="org-left">can acess proteced mem</td>
<td class="org-left">can acess private mem</td>
</tr>

<tr>
<td class="org-left">baseclass private function</td>
<td class="org-left">can acess public mem</td>
<td class="org-left">can acess proteced mem</td>
<td class="org-left">can acess private mem</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">friends function/class</td>
<td class="org-left">can acess public mem</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">can acess private mem</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">derived class</td>
<td class="org-left">can acess public mem</td>
<td class="org-left">can acess protected mem</td>
<td class="org-left">can't acess private mem</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Public    :    can acess  by everybody        :  either u are ouside, inside class or  derived class
Protected :    can't acess outide class 
Private   :    can acess only inside class and friend    
</p>
</div>
</div>

<div id="outline-container-org2912f73" class="outline-3">
<h3 id="org2912f73"><span class="done DONE">DONE</span> Function overload</h3>
<div class="outline-text-3" id="text-org2912f73">
</div>
<div id="outline-container-org6b94e2c" class="outline-4">
<h4 id="org6b94e2c">Introduction</h4>
<div class="outline-text-4" id="text-org6b94e2c">
<p>
Function overloading You can have multiple definitions for the same function name in the same scope. The definition of the function must differ from each other by the types and/or the number of arguments in the argument list. You can not overload function declarations that differ only by return type.
</p>

<p>
Following is the example where same function print() is being used to print different data types:
</p>
</div>
</div>

<div id="outline-container-orgc9b8cc3" class="outline-4">
<h4 id="orgc9b8cc3"><span class="todo TODO">TODO</span> Example</h4>
<div class="outline-text-4" id="text-orgc9b8cc3">
<div class="org-src-container">
<pre class="src src-cpp">class printData {
public:
  void print(int i)     { cout &lt;&lt; "Printing int: " &lt;&lt; i &lt;&lt; endl; }                 // Function overload
  void print(double  f) { cout &lt;&lt; "Printing float: " &lt;&lt; f &lt;&lt; endl; }               // Function overload
  void print(char* c)   { cout &lt;&lt; "Printing character: " &lt;&lt; c &lt;&lt; endl; }           // Function overload
};

int main(void) {
  printData pd;
  pd.print(5);              // Call print to print integer
  pd.print(500.263);        // Call print to print float
  pd.print("Hello C++");    // Call print to print character
  return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfac2307" class="outline-4">
<h4 id="orgfac2307">How it work</h4>
<div class="outline-text-4" id="text-orgfac2307">
<p>
when you comiple a prg and in function is called the function address is used to call a function know as (name mangling)  
</p>

<p>
compiler wil change name and stores it address of change name thus it wil overload function are not depend
</p>

<p>
so if prg call function(defined more than 1 function ) comiler know which function to call 
</p>
</div>
</div>

<div id="outline-container-orgf3f233e" class="outline-4">
<h4 id="orgf3f233e">Rules where function overload doesn't work</h4>
<div class="outline-text-4" id="text-orgf3f233e">
<ol class="org-ol">
<li>differ only in return type</li>
</ol>
<p>
void add(int x, int y)
int  add (int x, int y)
</p>
<ol class="org-ol">
<li>In Class: 
simillar function name and parameters  but one is static function another is non-static</li>
</ol>

<p>
static void add(int x, int y)
add (int x, int y)
</p>

<ol class="org-ol">
<li>same data type (int, double..) or (array, str) but one is var other is pointer or ref</li>
</ol>
<p>
int add (int a)
int add (int *a)
</p>

<ol class="org-ol">
<li>constant and volatile</li>
</ol>
<p>
int add(int arr)
void add ( volatile int x)
</p>

<ol class="org-ol">
<li>default parameter</li>
</ol>
<p>
void add (int x)
void add (int x =0)
</p>
</div>
</div>
<div id="outline-container-orgb4bcadb" class="outline-4">
<h4 id="orgb4bcadb">Function Hiding using scope</h4>
<div class="outline-text-4" id="text-orgb4bcadb">
<div class="org-src-container">
<pre class="src src-cpp">class Base {
public :
  int fun(int i) { count &lt;&lt; " Base "&lt;&lt;endl; }
};

class Derived : public Base{
public :
  // using Base :: fun;       // all 'fun' name in base should share same scope in Derived class
  int fun(char c) { count &lt;&lt; "Derived"&lt;&lt; endl; }

};

int main() {

  Derived d;
  d.fun(1);                          // Result : Derived
  d.fun('a');                        // Result : Derived

  // insted of fun(int i) it call fun(char c) but it call derived function
  // This is hidding but we can use base class fuction by using scope

  d.Base:: fun(2)

}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb7c35fc" class="outline-3">
<h3 id="orgb7c35fc">Operator Overloading</h3>
<div class="outline-text-3" id="text-orgb7c35fc">
<p>
Overloading operator : User-define or re-define built-in operator of c++
</p>
</div>

<div id="outline-container-orgd497baf" class="outline-4">
<h4 id="orgd497baf">Syntax for class members</h4>
<div class="outline-text-4" id="text-orgd497baf">
<div class="org-src-container">
<pre class="src src-cpp">ClassName operator+ (const ClassName&amp; obj){
  obj.var = this-&gt;lenght + obj.lenght;
  ...........
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb5a9c39" class="outline-4">
<h4 id="orgb5a9c39">Syntax for non-members functions</h4>
<div class="outline-text-4" id="text-orgb5a9c39">
<div class="org-src-container">
<pre class="src src-cpp">ClassName operator+ (const ClassName&amp;, const ClassName&amp;){

  ............
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org251c0cc" class="outline-4">
<h4 id="org251c0cc">Example</h4>
<div class="outline-text-4" id="text-org251c0cc">
<div class="org-src-container">
<pre class="src src-cpp">class Box{
private:
  double lenght, breadth, height;
public:
  double getVolume(void) {return (lenght*breath* height);}
  void getlenght(double len) {lenght= len;}
  void getbreath(double bre) {breadth= bre;}
  void setheight(double hei) {height= hei;}

  Box operator+(const Box&amp; obj2)                 // operator overloading
  {
   Box obj1;
   obj1.lenght = this-&gt;lenght + obj2.lenght;
   obj1.breadth = this-&gt;breadth + obj2.breadth;
   obj1.height = this-&gt;height + obj2.height;
   return obj1;
   }
};

int main(){
  Box box1, box2, box3;            // declare box1, box2, box3
  box1.setLength(6.0);
  box1.setBreadth(7.0);
  box1.setHeight(5.0);

  box2.setLength(12.0);
  box2.setBreadth(13.0);
  box2.setHeight(10.0);

  box3 = box1 + box2;
  volume = box3.getVolume();
  cout&lt;&lt; "Volume of box3 :"&lt;&lt; volume &lt;&lt; endl;
  return 0;
}  
</pre>
</div>
</div>
</div>

<div id="outline-container-org75bd240" class="outline-4">
<h4 id="org75bd240">Example without operator overloading</h4>
<div class="outline-text-4" id="text-org75bd240">
<div class="org-src-container">
<pre class="src src-cpp">struct Vec2
{
  float x,y;

  Vec2(float x, float y):x(x),y(y){};

  Vec2 Add(const Vec2 &amp;other) const
  { return  Vec2(x+ other.x , y + other.y); }

  Vec2 mul(const Vec2 &amp;other) const
  { return Vec2 (x * other.x, y+ other.y);}
};

int main()
{
  Vec2 p1(4.0f, 4.0f);
  Vec2 speed(0.5f, 1.5f);
  Vec2 powerup(1.1f, 1.2f);

  Vec2 result = p1.add(speed.mul(powerup)); // which means p1 + speed * powerup
}

</pre>
</div>
</div>
</div>
<div id="outline-container-org3cdb348" class="outline-4">
<h4 id="org3cdb348">Example with operator overloading</h4>
<div class="outline-text-4" id="text-org3cdb348">
<div class="org-src-container">
<pre class="src src-cpp">struct Vec2
{
  float x,y;

  Vec2(float x, float y):x(x),y(y){}

  Vec2 operator+ (const Vect &amp;other) const
  { return Vec2(x + other.x , y + other.y); }

  Vec2 operator*(const Vec2 &amp;other) const
  { return Vec2 (x * other.x, y* other.y);}

};

ostream&amp; operator&lt;&lt;(osteam&amp; stream1, const Vec2&amp; other)
{
  stream1 &lt;&lt;other.x&lt;&lt;","&lt;&lt;other.y;
  return steam1;
}

int main()
{
  Vec2 p1(4.0f, 4.0f);
  Vec2 speed(0.5f, 1.5f);
  Vec2 powerup(1.1f, 1.2f);
  Vec2 result =  p1 + speed * powerup   // operator overloading
  cout &lt;&lt; result2&lt;&lt; endl;  
}

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org2330de2" class="outline-3">
<h3 id="org2330de2">Object (Create / Instantiate Object)</h3>
<div class="outline-text-3" id="text-org2330de2">
<p>
Oject are create in two ways
stacks is small 1 or 2megabytes, faster
heap is slower 
</p>

<ul class="org-ul">
<li>Stacks (normal way to create a obj)</li>
<li>Heaps (using new and delete )</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9fea8ec" class="outline-2">
<h2 id="org9fea8ec">oops</h2>
<div class="outline-text-2" id="text-org9fea8ec">
</div>
<div id="outline-container-org1ce5b2d" class="outline-3">
<h3 id="org1ce5b2d">Inheritance</h3>
<div class="outline-text-3" id="text-org1ce5b2d">
</div>
<div id="outline-container-orgc21528d" class="outline-4">
<h4 id="orgc21528d">Introduction</h4>
<div class="outline-text-4" id="text-orgc21528d">
<p>
Allow to define a class in terms of another class
A new class is created based on exisiting(previous class)
</p>

<p>
NOTE: new class is called derived class
      existing class is called base class
</p>

<p>
Pros :
easier to create
reuse code
</p>
</div>
</div>
<div id="outline-container-orgc3ac0b4" class="outline-4">
<h4 id="orgc3ac0b4">Syntax</h4>
<div class="outline-text-4" id="text-orgc3ac0b4">
<div class="org-src-container">
<pre class="src src-cpp">class DerivedClass_Name : acess_specifier BaseClass_Name{ 
  // default acess specifier : privte
  ........
};
</pre>
</div>
</div>
</div>
<div id="outline-container-org9f31419" class="outline-4">
<h4 id="org9f31419">Example</h4>
<div class="outline-text-4" id="text-org9f31419">
<div class="org-src-container">
<pre class="src src-cpp">// base class
class Shape{
public :
  void setWidth(int w){
    width = w;
  }
  void setHeight(inth){
    height = h;
  }
protected:
  int width;
  int height;
};

// Derived Class
class Rectangle: public Shape{
public:
  int getArea(){
    return (width * height);
  }
};

int main(){
  Rectangle Rect;
  Rect.setWidth(5);
  Rect.setHeight(7);

  cout &lt;&lt; "Total area :" &lt;&lt;Rect.getArea() &lt;&lt; endl;
  return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org37cc935" class="outline-4">
<h4 id="org37cc935">Types of inheritance by Acess Specifier</h4>
<div class="outline-text-4" id="text-org37cc935">
<p>
In c++ there are 3 acess specifiers : public,private, protected
</p>

<p>
Inheritanec can be classifed into three types
</p>
</div>
<ul class="org-ul">
<li><a id="org22b6c43"></a>Public Inheritance :<br />
<div class="outline-text-5" id="text-org22b6c43">
<p>
base class public    members become derived   class public    members
base class protected members become protected class protected members
base class private   member  are indirectly become private   class private   members
</p>
</div>

<ul class="org-ul">
<li><a id="org015fdf3"></a>NOTE: Base class members are never accessible directly form a derived class, but an be access through public and private mem of base class<br /></li>
</ul>
</li>

<li><a id="org914d879"></a>Protected Inheritance:<br />
<div class="outline-text-5" id="text-org914d879">
<p>
Base class public,protected members become protected members of derived class
</p>
</div>
</li>

<li><a id="orga0b8b96"></a>Private Inheritane:<br />
<div class="outline-text-5" id="text-orga0b8b96">
<p>
Base class public,protected members become private members of derived class
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">acess\class</th>
<th scope="col" class="org-left">inside base class</th>
<th scope="col" class="org-left">Insidederived class</th>
<th scope="col" class="org-left">outside class</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">public</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">protected</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">privte</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgae25822" class="outline-4">
<h4 id="orgae25822">multipule Inheritance:</h4>
<div class="outline-text-4" id="text-orgae25822">
</div>
<ul class="org-ul">
<li><a id="org4e664ac"></a>Syntax<br />
<div class="outline-text-5" id="text-org4e664ac">
<div class="org-src-container">
<pre class="src src-cpp">class derive_ClassName : acess baseA, acess base B....{
  statemetns;
}
</pre>
</div>
</div>
</li>
<li><a id="org7620ff9"></a>Example<br />
<div class="outline-text-5" id="text-org7620ff9">
<div class="org-src-container">
<pre class="src src-cpp">// Base class 
class Shape {
public:
  void setWidth(int w){ width = w; }
  void setHeight(int h){ height = h;}
protected:
  int width;
  int height;
};

// base class
class PaintCost{
public :
  int getCost(int area){ return area*70;}
};

// Derived class
class Rectangle: public Shape, public PaintConst{
  int getArea() {return (width * height);}
};

int main(){
  Rectangle Rect;
  int area;
  Rect.setWidth(5);
  Rect.setWidth(7);
  area = Rect.getArea();

  cout&lt;&lt; "Total area :" &lt;&lt; Rect.getArea()&lt;&lt; endl;
  cound&lt;&lt; "Total paint cost :$" &lt;&lt; Rect.getCost(area)&lt;&lt;endl;
  return 0;
}    
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-org41a5c0f" class="outline-3">
<h3 id="org41a5c0f">Virtual and Pure Virtual Function:</h3>
<div class="outline-text-3" id="text-org41a5c0f">
</div>
<div id="outline-container-org4a47faf" class="outline-4">
<h4 id="org4a47faf">Example</h4>
<div class="outline-text-4" id="text-org4a47faf">
<p>
Base Class :
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">class: shape</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">method Draw()</td>
</tr>
</tbody>
</table>

<p>
Derived classes :
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">class: line</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">method Draw()</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">class: rectangle</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">method Draw()</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">class: triange</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">method Draw()</td>
</tr>
</tbody>
</table>


<div class="org-src-container">
<pre class="src src-cpp">class Shape{
protected:
  int width, height;
public:
  Shape(int a = 0, int b = 0){ width = a; height = b;}
  virtual int area()= 0;             // pure virtual function

  // =0 tell compiler that this function has no body and it is pure virtual function
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgeabf417" class="outline-4">
<h4 id="orgeabf417">Syntax</h4>
<div class="outline-text-4" id="text-orgeabf417">
<div class="org-src-container">
<pre class="src src-cpp">virtual &lt;data-type&gt; functionName(args);    // virtual function
virtual &lt;data-type&gt; functionName(args)=0;    // pure virtual function
</pre>
</div>

<p>
virtual function is a defined in a base class with another version (same function name ) in derived class, tells compiler that we don't want static linkage for this function
</p>
</div>
</div>
<div id="outline-container-org2130914" class="outline-4">
<h4 id="org2130914">Example for virtual function</h4>
<div class="outline-text-4" id="text-org2130914">
<div class="org-src-container">
<pre class="src src-cpp">Class Entity{
 public:
  virtual string GetName(){ return "Entity";}
};

Class Player : public Entity{
 private:
  string m_Name;
 public:
  Player(const string&amp; name):m_Name{name}{}
  string GetName() {return m_Name;}
  // in C++ new keywork override is used to specify this is used to override other function
  // string GenName() override { retun m_Name;} 
}
void PrintName( Entity * entity){
  cout&lt;&lt; entity-&gt; GetName()&lt;&lt;endl;
}

int main(){
  Entity* e = new Entity();
  PrintName(e);
  Player* p = new Player("Tony");

  cin.get();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0dc3f6b" class="outline-4">
<h4 id="org0dc3f6b">Pure virtual function :</h4>
<div class="outline-text-4" id="text-org0dc3f6b">
<ul class="org-ul">
<li>has no body (implementation part)</li>
<li>Pure Virtual function  is same as abstract method or interface in other prg language like java or c#.</li>
<li>Basically it allow us to define a function in base class which doesn't have implementatin and force (sub class or derived class) to actally implement</li>
</ul>
</div>
</div>
<div id="outline-container-org9d83dc1" class="outline-4">
<h4 id="org9d83dc1">Example for Pure Virtual Function</h4>
<div class="outline-text-4" id="text-org9d83dc1">
<p>
In above virtual function example 
</p>
<ul class="org-ul">
<li>we have a virtual function (GetName) in base class(Entity) which has a body</li>
<li>Then we have overide it by a (subclass)derived class fucntion</li>
<li>By having a body in base class means overiding function of base class is entirely optional</li>
<li>means by default compiler will exe base class function but n't derived class and</li>
<li>Some case it does't  make sense implemention in base class wt we want to force derived class to provied own defination</li>
</ul>

<p>
In OOP it is quite common to have base class consist of unimplemented method and force subclass to implement them is know as <b>Interface Class</b> or <b>Absstract Class</b>
</p>

<p>
Interface Class  doesn't have any implementation part so it n't instanciate a object. and forces derived class to implement 
</p>


<div class="org-src-container">
<pre class="src src-cpp">Class Entity{
 public:
  virtual string GetName()= 0;
};

Class Player : public Entity{
 private:
  string m_Name;
 public:
  Player(const string&amp; name):m_Name{name}{}
  string GetName() {return m_Name;}
}

int main(){
  Entity* e = new Entity(); // ERROR : Entity is virtual or abstract can't  instanciate
  PrintName(e);
  Player* p = new Player("Tony");

  cin.get();
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb8e3679" class="outline-4">
<h4 id="orgb8e3679">Example 2: Create fucntion which print class name</h4>
<div class="outline-text-4" id="text-orgb8e3679">
<div class="org-src-container">
<pre class="src src-cpp">Class Printable
{
 public :
  virtual string GetClassName()=0;
};

Class Entity : public Printable
{
 public:
  virtual string GetName(){return "Entity";}
  string GetClassName(){return "Entity";} 
};

Class Player : public Entity{
 private:
  string m_Name;
 public:
  Player(const string&amp; name):m_Name{name}{}
  string GetName() {return m_Name;}
}

void Print(Printable* obj)
{
  cout&lt;&lt; obj-&gt;GetClassName()&lt;&lt;endl;
}
int main(){
  Entity* e = new Entity();
  //  PrintName(e);
  Player* p = new Player("Tony");
  Print(e);
  Print(p);

  cin.get();
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd4dc750" class="outline-4">
<h4 id="orgd4dc750">How it work</h4>
<div class="outline-text-4" id="text-orgd4dc750">
</div>
<ul class="org-ul">
<li><a id="orgc865130"></a>V table :<br />
<div class="outline-text-5" id="text-orgc865130">
<p>
How does compiler know which Draw function should be used ?
Virtual function has some thing called dynamic dispach which compile implement by V table 
V table : TABLE consisting of all virtual function inside base class and map them
</p>
</div>
</li>
<li><a id="org59221cc"></a>Virtual Function is costly<br />
<div class="outline-text-5" id="text-org59221cc">
<p>
There are two run time cost 
</p>
<ol class="org-ol">
<li>memory to store V-table  (to dispach correct function include member pointer in base class)</li>

<li>every time we use function we need to go through this table to determine to which function</li>
</ol>
</div>
</li>
</ul>
</div>
<div id="outline-container-org3947fc1" class="outline-4">
<h4 id="org3947fc1">Dynamic Linkage :</h4>
<div class="outline-text-4" id="text-org3947fc1">
<p>
(when a function is called which version of function to be selected based on what kind of obj is called. This is also know as late binding ) 
</p>
</div>
</div>
</div>
<div id="outline-container-orgaf85c5f" class="outline-3">
<h3 id="orgaf85c5f">Interfaces by Abstract Class</h3>
<div class="outline-text-3" id="text-orgaf85c5f">
<p>
Interface : class without  committing to a particular implementation of class
</p>

<p>
Implemented by abstract class
</p>
</div>
<div id="outline-container-orgf7a1345" class="outline-4">
<h4 id="orgf7a1345">Defination</h4>
<div class="outline-text-4" id="text-orgf7a1345">
<p>
A class is called Abstract if declares at least one pure virtual function 
</p>

<p>
Abstract class does't have any implementation part hence it give error if we create(instantiate ) a object.
</p>

<p>
So abstract class are use to provide interface  to derived class where implementation part is present
</p>

<p>
If a derived class if there is atleast one pure virtual function then it is also called a abstract class and it can't instatiate obj
</p>

<p>
If in derived class (all pure function in base class) are implemented then it can used to create obj and called <code>concrete classes</code>
</p>
</div>
</div>

<div id="outline-container-org50c23f5" class="outline-4">
<h4 id="org50c23f5">Example :</h4>
<div class="outline-text-4" id="text-org50c23f5">
<div class="org-src-container">
<pre class="src src-cpp">class Shape{
protected:
  int width, height;
public:
  virtual int getArea()= 0;                // pure virtual function def
  void setWidth(int w) {width = w}
  void setHeight(int h){height = h;}
};
class Rectangle: public Shape{             
public:
  int getArea() {return (width * height);} // implementation of pure virtual function
};
class Triangle: public Shape{              
public:
  int getArea(){return (width*height/2);}  // implementation of pure virtual function
};

int main(){
  Rectangle Rect;
  Triangle Tri;
  Rect.setWidth(5);
  Rect.setHeight(7);
  cout&lt;&lt; "Total Rectangel area : "&lt;&lt;Rect.getArea()&lt;&lt;endl;
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7e43d67" class="outline-3">
<h3 id="org7e43d67">Abstraction</h3>
<div class="outline-text-3" id="text-org7e43d67">
<p>
Only show features to prg(outside world)  but hiddens the implementation details 
</p>

<p>
Advantage : 
  Reduce code complexity
  Hidding details and expose essentials part
</p>


<p>
eg: In Database System : hides details of how data is stored and create and mainted  
</p>

<p>
User does not know how data is stored, create, mainted (hiddes details)
</p>

<div class="org-src-container">
<pre class="src src-cpp">// Let there is expensive class Rocket

class Rocket{
  void fly()          // this contain very complex code and does not want to show other
  {.............}

  //   In order to not show it others
  //    &gt;  Compile class and convert to lib (showing funtion fly)
  //    &gt;   Prg can't  see implementation part but can use the fly  function 
}
</pre>
</div>

<p>
Abstraction is a method of expressing the important properties without involving the background details. On the other hand, Data hiding insulates the data from the straight access by the program
</p>
</div>
<div id="outline-container-orgdf3f143" class="outline-4">
<h4 id="orgdf3f143">Explination</h4>
<div class="outline-text-4" id="text-orgdf3f143">
<p>
abstraction is a mechanism of extracting the essential elements for the creation of a system, without its implementation details. In abstraction, we have to focus only on what is to be done instead of how it should be done. Abstraction is a thought process; it solves the problem at the design level.
</p>
</div>
</div>

<div id="outline-container-org54546fc" class="outline-4">
<h4 id="org54546fc"><span class="todo TODO">TODO</span> Data Abstracting</h4>
</div>
<div id="outline-container-orgc65f243" class="outline-4">
<h4 id="orgc65f243">Abstract Data Type:</h4>
<div class="outline-text-4" id="text-orgc65f243">
<p>
If you implement class with public &amp; private memberss is called Data Abstraction
</p>

<p>
Explaination :
members (attributes and function ) in public are accessable to outside world            # show features or important details 
members (attributes and function ) in private are n't accessiable to outside world      # hide implementation or background details
</p>
</div>
</div>
</div>

<div id="outline-container-org1913ae7" class="outline-3">
<h3 id="org1913ae7">Encapsulation</h3>
<div class="outline-text-3" id="text-org1913ae7">
<p>
Encapsulation means wrapping the implementation of data member and methods inside a class. When implementation of all the data member and methods inside a class are encapsulated
</p>

<p>
the method name can only describe what action it can perform on an object of that class
</p>

<p>
It also hides data but for protection and binds data and functions
</p>
</div>
</div>

<div id="outline-container-orgd58bbf0" class="outline-3">
<h3 id="orgd58bbf0">Data hiding</h3>
<div class="outline-text-3" id="text-orgd58bbf0">
<p>
Data Hiding means confirms the security of  members of a class from an illegal or unauthorized access. 
</p>

<p>
The main difference between data hiding and encapsulation is that 
</p>

<p>
data hiding focus more on data security and 
encapsulation focuses more on hiding the complexity of the system.
</p>

<p>
Ex: Audio player volume increase
</p>

<p>
Consider we have a vlc player where it volume [0 100] so we have desing this volume parameter
</p>
<div class="org-src-container">
<pre class="src src-cpp">class vlcplayer{
private:
  int volume_private;        // Here volume_private is hidden we can't access outside or accidenally change volume it should by public function
public:
  int volume_public;         // Here volume_pulic is not hidden we can access outside 
  vlcplayer():volume_private{0} {}
  void setVolume_private(int x){ 
    if (x&gt;=0&amp;&amp; x&lt;= 100){
      volume_private = x;
      cout&lt;&lt; "set voulume"&lt;&lt; endl;
    }
    else{
      cout &lt;&lt; "Can't Set"&lt;&lt; endl;
    }
  }
};

int main(){
  vlcplayer vlc;
  vlc.setVolume_private(50);
  vlc.setVolume_private(-30);
  vlc.volume_public = 10000;  
}
</pre>
</div>

<p>
NOTE: In general data is stored in private and implementation part is done in public
</p>
</div>
</div>
<div id="outline-container-org14d8b65" class="outline-3">
<h3 id="org14d8b65">Data Hiding vs Encapsulation</h3>
<div class="outline-text-3" id="text-org14d8b65">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">comparison</th>
<th scope="col" class="org-left">Data Hiding</th>
<th scope="col" class="org-left">Encapsulation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Basic</td>
<td class="org-left">About data security along with hiding complexity.</td>
<td class="org-left">About wrapping data to hide the complexity of a system.</td>
</tr>

<tr>
<td class="org-left">Focus</td>
<td class="org-left">Restricting or permitting the use of data inside the capsule.</td>
<td class="org-left">Enveloping or wrapping the complex data.</td>
</tr>

<tr>
<td class="org-left">Access Specifier</td>
<td class="org-left">data under data hiding is always private and inaccessible.</td>
<td class="org-left">Data under encapsulation may be private or public.</td>
</tr>

<tr>
<td class="org-left">Process</td>
<td class="org-left">Data hiding is a process as well as technique</td>
<td class="org-left">Encapsulation is a sub-process in data hiding.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgd3df533" class="outline-3">
<h3 id="orgd3df533">Polymorhism</h3>
<div class="outline-text-3" id="text-orgd3df533">
</div>
<div id="outline-container-orge125f58" class="outline-4">
<h4 id="orge125f58">Introduction</h4>
<div class="outline-text-4" id="text-orge125f58">
<p>
Polymorphism means having many forms. Typically, polymorphism occurs when there is a hierarchy of classes and they are related by inheritance.
</p>

<p>
C++ polymorphism means that a <code>call to a member function</code> will cause a <code>different function to be executed depending on the type of object</code> that invokes the function.
</p>

<p>
Consider the following example where a base class has been derived by other two classes:
</p>
</div>
</div>
<div id="outline-container-org9b1c22c" class="outline-4">
<h4 id="org9b1c22c">Example</h4>
<div class="outline-text-4" id="text-org9b1c22c">
<div class="org-src-container">
<pre class="src src-cpp">class Shape {
protected:
  int width, height;
public:
  Shape( int a = 0, int b = 0) {width = a;height = b;}
  int area() { cout &lt;&lt; "Parent class area :" &lt;&lt;endl;  return 0;}                       // Polymorhism obj is shape:  has same name in class
};

class Rectangle: public Shape {
public:
  Rectangle( int a = 0, int b = 0):Shape(a, b) { }
  int area () { cout &lt;&lt; "Rectangle class area :" &lt;&lt;endl; return (width * height); }    // Polymorphism obj is rectangle
};

class Triangle: public Shape{
public:
  Triangle( int a = 0, int b = 0):Shape(a, b) { }                                                
  int area () { cout &lt;&lt; "Triangle class area :" &lt;&lt;endl; return (width * height / 2);}   // Polymorphism obj is triangle  
};

int main( ) {
  Shape *shape;
  Rectangle rec(10,7);
  Triangle  tri(10,5);
  shape = &amp;rec;                // store the address of Rectangle
  shape-&gt;area();               // call rectangle area.  &gt;&gt; Rectangular class area : 70
  shape = &amp;tri;                
  shape-&gt;area();               // call triangel area     &gt;&gt; Triangle class area : 50
  return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org84f0100" class="outline-4">
<h4 id="org84f0100">How it work</h4>
<div class="outline-text-4" id="text-org84f0100">
<p>
when callingt  polymorphic mem function is set by compoler as version control in base class this is called <code>static resolution if function call</code> 
or static linkage
</p>

<p>
The function call is fixed before execution know as early bunding because compiler know which polymorphic  function should be called during compiling prg
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org3cc91fe" class="outline-2">
<h2 id="org3cc91fe">Interview Questions</h2>
<div class="outline-text-2" id="text-org3cc91fe">
</div>
<div id="outline-container-orgfd62209" class="outline-3">
<h3 id="orgfd62209">Difference between void and void pointer:</h3>
<div class="outline-text-3" id="text-orgfd62209">
<p>
void
used to denote nothing                       
if function dont return anything we use void 
</p>
</div>
</div>
<div id="outline-container-orgb215988" class="outline-3">
<h3 id="orgb215988">Difference in Reference variable and pointer variable</h3>
<div class="outline-text-3" id="text-orgb215988">
<p>
References are generally implemented using pointers. A reference is same object, just with a different name and reference must refer to an object. Since references cant be NULL, they are safer to use.
</p>


<p>
&gt; Pointer can be assigned NULL directly, whereas reference cannot.
&gt; Pointers can iterate over an array, we can use ++ to go to the next item that a pointer is pointing to.
&gt; pointer is a variable that holds a memory address. A reference has the same memory address as the item it references.
&gt; pointer to a class/struct uses -&gt;'(arrow operator) to access its members whereas a reference uses a .'(dot operator)
&gt; pointer needs to be dereferenced with * to access the memory location it points to, whereas a reference can be used directly.
</p>
</div>
</div>

<div id="outline-container-org7ad2434" class="outline-3">
<h3 id="org7ad2434">multiple return value</h3>
<div class="outline-text-3" id="text-org7ad2434">
<p>
by using a struct and putting all the return value and 
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Cherno</p>
<p class="date">Created: 2023-03-16 Thu 11:43</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
